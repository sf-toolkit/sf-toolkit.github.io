import { hashContent, moduleSpecifierToKebabCase, stringToVariableName } from '@lwrjs/shared-utils';
import { ViewSpan } from '@lwrjs/instrumentation';
import { getSsrServices, parseBootstrapSpecifier } from '../identity.js';
/**
 * TODO: refactor comma separated approach: W-15108877
 *
 * This module provider generates code to prefetch data and server-side render a given component.
 * It handles module specifiers in the form: "@lwrjs/lwc-ssr/${route ID}/${component specifier},${component specifier}...".
 * eg: "@lwrjs/lwc-ssr/home/my/about,my/nav,my/banner"
 */
// Call rootComponent.getServerData() to get the props, head markup and TTL
function createDataCall(rootSpecifier, classImportName) {
    return `\n
    results['${rootSpecifier}'] = { props: context.props['${rootSpecifier}'] }; // props from HTML attributes
    if (${classImportName}.getServerData) {
        await globalThis.trace({
            name: '${ViewSpan.GetServerData}',
            attributes: { specifier: '${rootSpecifier}' }
        }, async() => {
            try {
                const data${classImportName} = await ${classImportName}.getServerData({ ...context, props: results['${rootSpecifier}'].props });
                Object.assign(serverData, data${classImportName}.props); // add props to server data
                Object.assign(results['${rootSpecifier}'], { props: data${classImportName}.props, markup: data${classImportName}.markup, cache: data${classImportName}.cache });
            } catch(e) {
                // add the root component specifier to the error message
                errors['${rootSpecifier}'] = 'Error in "getServerData" for "${rootSpecifier}": ' + stringifyError(e);
            }
        });
    }`;
}
// Call an SSR bootstrap service
function createServiceCall(serviceSpecifier, importName) {
    return `\n
    globalThis.trace({
        name: '${ViewSpan.BootstrapService}',
        attributes: { serviceSpecifier: '${serviceSpecifier}' }
    }, () => {
        try {
            ${importName}({ serverData });
        } catch(e) {
            // add the service specifier to the error message
            errors['${serviceSpecifier}'] = 'An SSR error occurred in bootstrap service "${serviceSpecifier}": ' + stringifyError(e);
        }
    });`;
}
// SSR a root component to get its HTML string
function createSsrCall(rootSpecifier, ctorImportName) {
    return `\n
    if (!errors['${rootSpecifier}']) { // skip SSR if getServerData failed
        const existingTaskCount${ctorImportName} = process.getActiveResourcesInfo ? process.getActiveResourcesInfo().length : 0;
        const html${ctorImportName} = globalThis.trace({
            name: '${ViewSpan.RenderComponent}',
            attributes: { specifier: '${rootSpecifier}' }
        }, () => {
            try {
                return renderComponent('${moduleSpecifierToKebabCase(rootSpecifier)}', ${ctorImportName}, results['${rootSpecifier}'].props || {});
            } catch(e) {
                // add the LWC rendering stack to the error message
                const message = e.message || stringifyError(e);
                const error = e.wcStack 
                    ? 'An error occurred during server-side rendering for component stack: ' + e.wcStack + '. Error was: ' + message
                    : 'An error occurred during server-side rendering: ' + message;
                errors['${rootSpecifier}'] = error;
            }
        });
        const currentTaskCount${ctorImportName} = process.getActiveResourcesInfo ? process.getActiveResourcesInfo().length : 0;
        if (currentTaskCount${ctorImportName} - existingTaskCount${ctorImportName} > 0) {
            console.warn('[warn] async tasks encountered while server rendering "${rootSpecifier}"');
        }
        Object.assign(results['${rootSpecifier}'], { html: html${ctorImportName} });
    }`;
}
/**
 * Create the virtual source for a module which server-side renders the given component.
 * This code is meant to be executed in a worker on the server; it is run from "lwc-ssr/viewTransformer#ssr-bootstrap" during linking.
 * The result is returned to the caller and the Promise in the main thread resolves.
 * If available, getServerData() is called on the root component to mutate context.props and gather page markup
 * All bootstrap services with { ssr: true } are executed after fetching data and prior to SSRing (for SSRed routes)
 * @param rootSpecifiers - The specifiers for the root components
 * @returns the generated module source
 */
function createServerBootstrapModule(rootSpecifiers, isSSR, services) {
    let rootImports = '', dataCalls = '', ssrCalls = '';
    // TODO: W-15109155 stop SSR on error when CSR fallback is disabled
    rootSpecifiers.forEach((root) => {
        const ctorImportName = stringToVariableName(`Ctor_${root}`);
        const classImportName = stringToVariableName(`root_${root}`);
        rootImports += `\nimport ${ctorImportName}, * as ${classImportName} from '${root}';`;
        dataCalls += createDataCall(root, classImportName);
        ssrCalls += isSSR ? createSsrCall(root, ctorImportName) : '';
    });
    let serviceImports = '', serviceCalls = '';
    services.forEach((serviceSpecifier) => {
        const importName = stringToVariableName(`service_${serviceSpecifier}`);
        serviceImports += `\nimport ${importName} from '${serviceSpecifier}';`;
        serviceCalls += createServiceCall(serviceSpecifier, importName);
    });
    return `
import { renderComponent } from '@lwc/engine-server';${rootImports}${serviceImports}

(async () => {
    const results = {}; // { rootSpecifier: { html, props, markup, cache } }
    const errors = {};  // { rootSpecifier: error string }
    const serverData = globalThis.LWR?.serverData || {}; // data from view providers
    const context = globalThis.getContext(); // SsrRequestContext

    // 1. cleanup the LWR global properties before any customer code is run
    if (globalThis.LWR?.define) {
        // AMD: support dynamic imports in getServerData
        globalThis.LWR = Object.freeze({ define: globalThis.LWR.define, env: globalThis.LWR.env });
    } else {
        // ESM
        globalThis.LWR = Object.freeze({ env: globalThis.LWR.env });
    }

    // 2. pre-fetch data
    ${dataCalls}
    // 3. execute each SSR bootstrap service
    ${serviceCalls}
    // 4. render components
    ${ssrCalls}
    // 5. relay results
    globalThis.resolver({ results, errors });
})()`;
}
export default class ServerModuleProvider {
    constructor(providerConfig, { config, runtimeEnvironment: { lwrVersion } }) {
        this.name = 'server-bootstrap-module-provider';
        this.version = lwrVersion;
        this.routes = [...config.routes, ...config.errorRoutes];
    }
    async getModuleEntry({ specifier }) {
        if (parseBootstrapSpecifier(specifier)) {
            const virtualId = `<virtual>/${specifier}`;
            return {
                id: `${virtualId}|${this.version}`,
                virtual: true,
                entry: virtualId,
                specifier,
                version: this.version,
            };
        }
    }
    async getModule({ specifier, namespace, name }) {
        const moduleEntry = await this.getModuleEntry({ specifier });
        if (!moduleEntry) {
            return;
        }
        // Generate the module source and return the Module
        const { route, rootSpecifiers } = parseBootstrapSpecifier(specifier, this.routes);
        const originalSource = createServerBootstrapModule(rootSpecifiers, !!route?.bootstrap.ssr, getSsrServices(route));
        return {
            id: moduleEntry.id,
            namespace,
            name: name || specifier,
            version: this.version,
            specifier,
            moduleEntry,
            ownHash: hashContent(originalSource),
            originalSource,
            compiledSource: originalSource,
        };
    }
}
//# sourceMappingURL=index.js.map