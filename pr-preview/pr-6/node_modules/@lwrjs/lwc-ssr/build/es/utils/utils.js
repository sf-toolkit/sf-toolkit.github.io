import { logger, stringifyError } from '@lwrjs/diagnostics';
import { ViewSpan } from '@lwrjs/instrumentation';
import { REQUEST_DEPTH_HEADER } from '@lwrjs/shared-utils';
const DEFAULT_SSR_TIMEOUT = 5000; // 5 seconds, override with process.env.SSR_TIMEOUT
export function getWatchdogTime() {
    const override = process.env.SSR_TIMEOUT;
    return override ? Number.parseInt(override) : DEFAULT_SSR_TIMEOUT;
}
export function startWatchdogTimer(callback, time) {
    return setTimeout(callback, time);
}
export function stopWatchdogTimer(timerId) {
    clearTimeout(timerId);
}
export class FetchController {
    constructor(fetchEndowment) {
        this.controlledFetch = (request, init) => {
            if (this.killSwitchActivated) {
                return this.handleAbortError(request, undefined);
            }
            const controller = new AbortController();
            // Ensure the init object exists and then add the signal to it.
            const updatedInit = { ...init, signal: controller.signal };
            this.controllers.add(controller);
            const fetchPromise = this.fetchEndowment(request, updatedInit)
                .catch((error) => {
                // Check if the error is an AbortError
                if (this.killSwitchActivated) {
                    return this.handleAbortError(request, error);
                }
                else {
                    // Re-throw the error if it's not an AbortError
                    throw error;
                }
            })
                .finally(() => {
                this.controllers.delete(controller);
            });
            return fetchPromise;
        };
        this.activateKillSwitch = () => {
            this.killSwitchActivated = true;
            this.controllers.forEach((controller) => {
                controller.abort();
            });
            this.controllers.clear(); // Clear the set as all fetch calls have been aborted
        };
        this.killSwitchActivated = false;
        this.controllers = new Set();
        this.fetchEndowment = fetchEndowment;
    }
    handleAbortError(request, error) {
        const message = `Orphaned ${String(request)} request was killed. Async processes are not supported during SSR. For more information, see: https://developer.salesforce.com/docs/platform/lwr/guide/lwr-configure-component-ssr.html.`;
        logger.warn({ label: `Server-side Rendering`, message }, error);
        // Return a response to indicate kill switch
        return Promise.resolve(new Response(message, { status: 500 }));
    }
}
export function createFetchEndowment(trace, host = '', requestCount = 1) {
    return (request, init) => {
        let finalRequest;
        let finalUrl;
        if (request instanceof Request) {
            const curUrl = request.url;
            // proxy relative URLs through the host
            if (curUrl.startsWith('/')) {
                finalUrl = host + curUrl;
                finalRequest = new Request(finalUrl, request);
            }
            else {
                finalUrl = curUrl;
                finalRequest = request;
            }
        }
        else {
            const curUrl = typeof request === 'string' ? request : request.toString(); // handle string-able types, eg: URL
            finalRequest = finalUrl = curUrl.startsWith('/') ? host + curUrl : curUrl; // proxy relative URLs through the host
        }
        const finalInit = {
            ...init,
            headers: {
                ...init?.headers,
                [REQUEST_DEPTH_HEADER]: String(requestCount),
            },
        };
        return trace({ name: ViewSpan.Fetch, attributes: { url: String(finalUrl) } }, () => 
        // this trace will NOT fail if fetch fails; it is meant to log the URLs fetched from the server
        // the fetch caller (ie: getServerData) should handle the error if response.ok is false
        // if the caller throws the fetch error, then it will be surfaced in the PARENT traces:
        // lwr.view.ssr.fetch (this) > lwr.view.ssr > lwr.view.ssr.island > lwr.view.render > lwr.handle.view
        fetch(finalRequest, finalInit));
    };
}
// TODO: enable createFetchEndowment() for worker_threads
// Only wrap fetch once to avoid issues during ssr
export const FETCH_ENDOWMENT = `
if(!globalThis.isFetchWrapped) {
globalThis.isFetchWrapped = true;
globalThis.fetchClassic = fetch;
const coreHost = workerData.host; delete workerData.host;
const requestDepth = workerData.requestDepth; delete workerData.requestDepth;
globalThis.fetch = (url, init) => {
    const headers = {...init?.headers, '${REQUEST_DEPTH_HEADER}': String(requestDepth)};
    const urlStr = typeof url === 'string' ? url : url.toString();
    const finalUrl = urlStr.startsWith('/') ? (coreHost || '') + url : url;
    return globalThis.trace({ name: 'lwr.view.ssr.fetch', attributes: { url: finalUrl } },
        () => fetchClassic(finalUrl, {...init, headers})
    );
}
}`;
export const TRACER = `globalThis.trace = (id, fn) => fn()`;
export function createSsrErrorMessage(specifier, e) {
    return `Server-side rendering for "${specifier}" failed. Falling back to client-side rendering. Reason: ${stringifyError(e)}`;
}
//# sourceMappingURL=utils.js.map