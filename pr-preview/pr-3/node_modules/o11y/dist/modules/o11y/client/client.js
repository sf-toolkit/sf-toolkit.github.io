import { networkSchema, simpleSchema, payloadDiagsSchema, errorSchema, activitySchema, instrumentedEventSchema, idleDetectorReportSchema } from 'o11y_schema/sf_instrumentation';
import { utility, PublicSafety, schemaUtil, UpCounterImpl, maxStringLengthAppLimit, payloadUtility, metricsUtility, co11y } from 'o11y/shared';

class TaskerImpl {
    get isBusy() {
        return this._isOk ? this._busyCount > 0 : undefined;
    }
    constructor(name, initialCount, _doneCallback, _overDoneCallback) {
        this.name = name;
        this._doneCallback = _doneCallback;
        this._overDoneCallback = _overDoneCallback;
        this._busyCount = 0;
        this._isOk = true;
        this._busyCount = initialCount;
    }
    add() {
        if (this._isOk) {
            this._busyCount += 1;
        }
    }
    done() {
        if (this._isOk) {
            if (this._busyCount > 0) {
                this._busyCount -= 1;
                if (!this._busyCount) {
                    this._doneCallback();
                }
            }
            else {
                this._isOk = false;
                this._overDoneCallback();
            }
        }
    }
}

const defaultLogThreshold = 300;
class IdleDetectorImpl {
    constructor(options) {
        this._taskers = new Map();
        this._listeners = new Set();
        this._busyCheckers = new Map();
        this._logThreshold = defaultLogThreshold;
        this._endedTasks = new Array();
        this._pollableReport = new Array();
        if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.logThreshold, 'options.logThreshold', 'number')) {
            this._logThreshold = options.logThreshold;
        }
        if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.reportListener, 'options.reportListener', 'function')) {
            this._reportListener = options.reportListener;
        }
        if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.errorListener, 'options.errorListener', 'function')) {
            this._errorListener = options.errorListener;
        }
    }
    requestIdleDetectedCallback(callback) {
        utility.requireArgument(callback, 'callback', 'function');
        if (this._listeners.size === 0) {
            this._firstCallbackTime = utility.time().perfNow;
        }
        this._listeners.add(callback);
        this._checkIfLoaded();
    }
    _reportTaskEnded(tasker) {
        if (this._listeners.size) {
            const snapshot = Object.assign({}, this._taskers.get(tasker));
            this._endedTasks.push(snapshot);
        }
    }
    declareNotifierTaskSingle(name) {
        utility.requireArgument(name, 'name', 'string');
        const tasker = this._addTasker(name, 1);
        const retVal = {
            get isBusy() {
                return tasker.isBusy;
            },
            done: () => {
                tasker.done();
                this._taskers.delete(tasker);
            }
        };
        return retVal;
    }
    declareNotifierTaskMulti(name, existingBusyCount = 0) {
        utility.requireArgument(name, 'name', 'string');
        if (existingBusyCount !== undefined) {
            utility.requireArgument(existingBusyCount, 'existingBusyCount', 'number');
            if (!Number.isInteger(existingBusyCount) || existingBusyCount < 0) {
                throw new Error('existingBusyCount accepts only non-negative integers');
            }
        }
        const tasker = this._addTasker(name, existingBusyCount);
        const retVal = {
            get isBusy() {
                return tasker.isBusy;
            },
            add: () => {
                if (!tasker.isBusy) {
                    const meta = this._taskers.get(tasker);
                    meta.start = utility.time().perfNow;
                    meta.end = undefined;
                }
                tasker.add();
            },
            done: tasker.done.bind(tasker)
        };
        return retVal;
    }
    declarePollableTaskMulti(name, isBusyChecker) {
        utility.requireArgument(name, 'name', 'string');
        utility.requireArgument(isBusyChecker, 'isBusyChecker', 'function');
        this._busyCheckers.set(isBusyChecker, name);
    }
    _addTasker(name, existingBusyCount) {
        const tasker = new TaskerImpl(name, existingBusyCount, () => {
            this._taskers.get(tasker).end = utility.time().perfNow;
            this._reportTaskEnded(tasker);
            this._checkIfLoaded();
        }, () => {
            var _a;
            (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, `Overdone: ${tasker.name}`);
            utility.noProdThrow(`Tasker '${tasker.name}' is done too many times.`);
        });
        this._taskers.set(tasker, {
            name,
            start: existingBusyCount > 0 ? utility.time().perfNow : undefined,
            end: undefined
        });
        return tasker;
    }
    _areAllNotifiersIdle() {
        return !Array.from(this._taskers.keys()).some((t) => t.isBusy);
    }
    _getFirstBusyPollable() {
        const entry = Array.from(this._busyCheckers).find((entry) => {
            var _a;
            const isBusyChecker = entry[0];
            const name = entry[1];
            try {
                return isBusyChecker();
            }
            catch (e) {
                (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, e, `BusyChecker ${name}`);
                utility.noProdThrow(e);
                return false;
            }
        });
        return entry ? entry[1] : undefined;
    }
    _checkIfLoaded() {
        if (!this._listeners.size) {
            return;
        }
        if (this._timerCheckQueued) {
            clearTimeout(this._timerCheckQueued);
        }
        if (this._areAllNotifiersIdle()) {
            this._timerCheckQueued = setTimeout(() => {
                this._timerCheckQueued = setTimeout(() => {
                    this._doubleCheck();
                }, 40);
            }, 0);
        }
    }
    _doubleCheck() {
        this._timerCheckQueued = undefined;
        if (this._areAllNotifiersIdle()) {
            const pollableName = this._getFirstBusyPollable();
            if (pollableName !== undefined) {
                this._addToPollableReport(pollableName);
                this._timerCheckQueued = setTimeout(() => {
                    this._doubleCheck();
                }, 15);
            }
            else {
                const maxDuration = utility.time().perfNow - this._firstCallbackTime;
                const listeners = Array.from(this._listeners.values());
                this._listeners.clear();
                this._firstCallbackTime = undefined;
                const endedTasks = this._endedTasks.splice(0);
                const pollableReport = this._pollableReport.splice(0);
                this._notify(listeners, maxDuration, endedTasks, pollableReport);
            }
        }
    }
    _addToPollableReport(name) {
        const lastEntry = this._pollableReport.length
            ? this._pollableReport[this._pollableReport.length - 1]
            : undefined;
        if ((lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.name) === name) {
            lastEntry.count += 1;
        }
        else {
            this._pollableReport.push({
                name,
                count: 1
            });
        }
    }
    _notify(listeners, maxDuration, taskReport, pollableReport) {
        var _a;
        if (maxDuration >= this._logThreshold && this._reportListener) {
            const logData = this._getReport(maxDuration, listeners.length, taskReport, pollableReport);
            this._reportListener(logData);
        }
        listeners.reverse();
        const tsNow = utility.time().tsNow;
        for (const [index, listener] of listeners.entries()) {
            try {
                listener(tsNow);
            }
            catch (e) {
                (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, e, `Listener #${listeners.length - 1 - index}`);
                utility.noProdThrow(e);
            }
        }
    }
    getReport() {
        const perfNow = utility.time().perfNow;
        const maxDuration = this._firstCallbackTime > 0 ? perfNow - this._firstCallbackTime : undefined;
        const onGoingTasks = Array.from(this._taskers.entries())
            .filter((e) => e[0].isBusy)
            .map((e) => ({
            name: e[1].name,
            start: e[1].start,
            end: perfNow
        }));
        return this._getReport(maxDuration, this._listeners.size, this._endedTasks.concat(onGoingTasks), this._pollableReport);
    }
    _getReport(maxDuration, listenerCount, taskReport, pollableReport) {
        const sortedTaskers = taskReport
            .map((t) => ({
            name: t.name,
            duration: t.end - t.start
        }))
            .sort((a, b) => b.duration - a.duration);
        return {
            logThreshold: this._logThreshold,
            maxDuration,
            listenerCount,
            pollableCount: this._busyCheckers.size,
            busyTasks: sortedTaskers.map((t) => t.name),
            busyDurations: sortedTaskers.map((t) => t.duration),
            pollables: pollableReport.map((p) => p.name),
            pollCounts: pollableReport.map((p) => p.count)
        };
    }
}

const navigation_timing={namespace:"sfcore.performance",name:"NavigationTiming",pbjsSchema:{"nested":{"sfcore":{"nested":{"performance":{"nested":{"NavigationTiming":{"oneofs":{"_xhrDelay":{"oneof":["xhrDelay"]},"_renderBlockingStatus":{"oneof":["renderBlockingStatus"]},"_firstInterimResponseStart":{"oneof":["firstInterimResponseStart"]},"_srvDuration":{"oneof":["srvDuration"]},"_isCdnCached":{"oneof":["isCdnCached"]},"_dbDuration":{"oneof":["dbDuration"]},"_reqBatchCount":{"oneof":["reqBatchCount"]}},
"fields":{"redirectCount":{"id":37,"type":"uint32"},"encodedBodySize":{"id":21,"type":"uint32"},"reqActionNames":{"rule":"repeated","id":28,"type":"string"},"unloadEventEnd":{"id":40,"type":"double"},"responseEnd":{"id":19,"type":"double"},"domainLookupEnd":{"id":12,"type":"double"},"unloadEventStart":{"id":39,"type":"double"},"domContentLoadedEventStart":{"id":32,"type":"double"},"type":{"id":38,"type":"string"},"firstInterimResponseStart":{"options":{"proto3_optional":true},"id":18,"type":"double"},
"duration":{"id":3,"type":"double"},"decodedBodySize":{"id":22,"type":"uint32"},"redirectStart":{"id":8,"type":"double"},"connectEnd":{"id":15,"type":"double"},"isCdnCached":{"options":{"proto3_optional":true},"id":24,"type":"bool"},"requestStart":{"id":16,"type":"double"},"startTime":{"id":2,"type":"double"},"fetchStart":{"id":10,"type":"double"},"domContentLoadedEventEnd":{"id":33,"type":"double"},"srvReqId":{"id":29,"type":"string"},"reqBatchCount":{"options":{"proto3_optional":true},"id":27,"type":"uint32"},
"renderBlockingStatus":{"options":{"proto3_optional":true},"id":6,"type":"string"},"workerStart":{"id":7,"type":"double"},"responseStart":{"id":17,"type":"double"},"xhrDelay":{"options":{"proto3_optional":true},"id":30,"type":"double"},"domInteractive":{"id":34,"type":"double"},"domComplete":{"id":31,"type":"double"},"domainLookupStart":{"id":11,"type":"double"},"responseStatus":{"id":23,"type":"uint32"},"redirectEnd":{"id":9,"type":"double"},"transferSize":{"id":20,"type":"uint32"},"srvDuration":{"options":{"proto3_optional":true},
"id":26,"type":"double"},"dbDuration":{"options":{"proto3_optional":true},"id":25,"type":"double"},"connectStart":{"id":13,"type":"double"},"loadEventStart":{"id":35,"type":"double"},"secureConnectionStart":{"id":14,"type":"double"},"name":{"id":1,"type":"string"},"nextHopProtocol":{"id":5,"type":"string"},"initiatorType":{"id":4,"type":"string"},"loadEventEnd":{"id":36,"type":"double"}}}}}}}}}};

const resource_timing={namespace:"sfcore.performance",name:"ResourceTiming",pbjsSchema:{"nested":{"sfcore":{"nested":{"performance":{"nested":{"ResourceTiming":{"oneofs":{"_xhrDelay":{"oneof":["xhrDelay"]},"_renderBlockingStatus":{"oneof":["renderBlockingStatus"]},"_firstInterimResponseStart":{"oneof":["firstInterimResponseStart"]},"_srvDuration":{"oneof":["srvDuration"]},"_isCdnCached":{"oneof":["isCdnCached"]},"_dbDuration":{"oneof":["dbDuration"]},"_reqBatchCount":{"oneof":["reqBatchCount"]}},
"fields":{"encodedBodySize":{"id":21,"type":"uint32"},"reqActionNames":{"rule":"repeated","id":28,"type":"string"},"responseEnd":{"id":19,"type":"double"},"domainLookupEnd":{"id":12,"type":"double"},"firstInterimResponseStart":{"options":{"proto3_optional":true},"id":18,"type":"double"},"duration":{"id":3,"type":"double"},"decodedBodySize":{"id":22,"type":"uint32"},"redirectStart":{"id":8,"type":"double"},"connectEnd":{"id":15,"type":"double"},"isCdnCached":{"options":{"proto3_optional":true},"id":24,
"type":"bool"},"requestStart":{"id":16,"type":"double"},"startTime":{"id":2,"type":"double"},"fetchStart":{"id":10,"type":"double"},"srvReqId":{"id":29,"type":"string"},"reqBatchCount":{"options":{"proto3_optional":true},"id":27,"type":"uint32"},"renderBlockingStatus":{"options":{"proto3_optional":true},"id":6,"type":"string"},"workerStart":{"id":7,"type":"double"},"responseStart":{"id":17,"type":"double"},"xhrDelay":{"options":{"proto3_optional":true},"id":30,"type":"double"},"domainLookupStart":{"id":11,
"type":"double"},"responseStatus":{"id":23,"type":"uint32"},"redirectEnd":{"id":9,"type":"double"},"transferSize":{"id":20,"type":"uint32"},"srvDuration":{"options":{"proto3_optional":true},"id":26,"type":"double"},"dbDuration":{"options":{"proto3_optional":true},"id":25,"type":"double"},"connectStart":{"id":13,"type":"double"},"secureConnectionStart":{"id":14,"type":"double"},"name":{"id":1,"type":"string"},"nextHopProtocol":{"id":5,"type":"string"},"initiatorType":{"id":4,"type":"string"}}}}}}}}}};

class FuzzyMapper {
    constructor(_fuzzyKeyRange) {
        this._fuzzyKeyRange = _fuzzyKeyRange;
        this._map = new Map();
        utility.requireArgument(_fuzzyKeyRange, '_fuzzyKeyRange', 'number');
    }
    add(key, fuzzyKey, value) {
        const mapValue = this._map.get(key);
        if (mapValue) {
            mapValue.push({ fuzzyKey, value });
        }
        else {
            this._map.set(key, [{ fuzzyKey, value }]);
        }
    }
    pop(key, fuzzyKey) {
        const mapValues = this._map.get(key);
        if ((mapValues === null || mapValues === void 0 ? void 0 : mapValues.length) >= 1) {
            let minDelta = Number.POSITIVE_INFINITY;
            let minIndex = -1;
            for (let index = 0; index < mapValues.length; index++) {
                const { fuzzyKey: curFuzzyKey } = mapValues[index];
                const curDelta = Math.abs(curFuzzyKey - fuzzyKey);
                if (curDelta <= this._fuzzyKeyRange && curDelta < minDelta) {
                    minDelta = curDelta;
                    minIndex = index;
                }
            }
            if (minIndex >= 0) {
                const { value } = mapValues.splice(minIndex, 1)[0];
                if (mapValues.length === 0) {
                    this._map.delete(key);
                }
                return value;
            }
        }
        return undefined;
    }
    clear() {
        this._map.clear();
    }
}

const basicInitiatorTypes = ['fetch', 'xmlhttprequest'];
class PerformanceObservability {
    constructor(_instr, fuzzyMapRange, _skipUrls, _logPerformanceActivityName, logLevel) {
        this._instr = _instr;
        this._skipUrls = _skipUrls;
        this._logPerformanceActivityName = _logPerformanceActivityName;
        this._isStarted = false;
        utility.requireArgument(_instr, '_instr', 'object');
        utility.requireArgument(fuzzyMapRange, 'fuzzyMapRange', 'number');
        utility.requireArgumentIfDefined(_skipUrls, '_skipUrls', Array);
        utility.requireArgumentIfDefined(_logPerformanceActivityName, '_logPerformanceActivityName', 'string');
        utility.requireArgumentIfDefined(logLevel, 'logLevel', 'string');
        this._hasPerf =
            typeof performance !== 'undefined' && typeof PerformanceObserver === 'function';
        this._boundObserverCallback = this._logPerformanceEntries.bind(this);
        if (!logLevel || logLevel.toLowerCase() === 'full') {
            this._logLevel = 1;
        }
        else if ((logLevel === null || logLevel === void 0 ? void 0 : logLevel.toLowerCase()) === 'basic') {
            this._logLevel = 0;
        }
        else {
            throw new Error(`Invalid log level: ${logLevel}`);
        }
        this._fuzzyMapper = new FuzzyMapper(fuzzyMapRange);
    }
    get isStarted() {
        return this._isStarted;
    }
    get logLevel() {
        return this._logLevel;
    }
    start() {
        if (!this._hasPerf) {
            return;
        }
        if (!this._isStarted) {
            this._isStarted = true;
            this._navigationObserver = new PerformanceObserver(this._boundObserverCallback);
            this._navigationObserver.observe({ type: 'navigation', buffered: true });
            this._resourceObserver = new PerformanceObserver(this._boundObserverCallback);
            this._resourceObserver.observe({ type: 'resource', buffered: true });
        }
    }
    stop() {
        if (this._resourceObserver) {
            this._resourceObserver.disconnect();
            this._resourceObserver = undefined;
        }
        if (this._navigationObserver) {
            this._navigationObserver.disconnect();
            this._navigationObserver = undefined;
        }
        this._fuzzyMapper.clear();
        this._isStarted = false;
    }
    addEntry(absoluteUrl, perfTime, data) {
        this._fuzzyMapper.add(absoluteUrl, perfTime, data);
    }
    _resourceEntryToResourceTiming(prt) {
        var _a, _b;
        const rt = {
            name: prt.name,
            startTime: prt.startTime,
            duration: prt.duration,
            initiatorType: prt.initiatorType,
            nextHopProtocol: prt.nextHopProtocol,
            renderBlockingStatus: prt.renderBlockingStatus,
            workerStart: prt.workerStart,
            redirectStart: prt.redirectStart,
            redirectEnd: prt.redirectEnd,
            fetchStart: prt.fetchStart,
            domainLookupStart: prt.domainLookupStart,
            domainLookupEnd: prt.domainLookupEnd,
            connectStart: prt.connectStart,
            secureConnectionStart: prt.secureConnectionStart,
            connectEnd: prt.connectEnd,
            requestStart: prt.requestStart,
            responseStart: prt.responseStart,
            firstInterimResponseStart: prt.firstInterimResponseStart,
            responseEnd: prt.responseEnd,
            transferSize: prt.transferSize,
            encodedBodySize: prt.encodedBodySize,
            decodedBodySize: prt.decodedBodySize,
            responseStatus: prt.responseStatus
        };
        const sts = prt.serverTiming;
        if (Array.isArray(sts)) {
            rt.dbDuration = (_a = sts.find((st) => st.name === 'db')) === null || _a === void 0 ? void 0 : _a.duration;
            rt.srvDuration = (_b = sts.find((st) => st.name === 'Total')) === null || _b === void 0 ? void 0 : _b.duration;
        }
        return rt;
    }
    _shouldInclude(entry) {
        var _a;
        const isFiltered = (_a = this._skipUrls) === null || _a === void 0 ? void 0 : _a.some((skipUrl) => {
            if (skipUrl instanceof RegExp) {
                return skipUrl.test(entry.name);
            }
            else {
                return entry.name === skipUrl;
            }
        });
        if (isFiltered) {
            return false;
        }
        if (this._logLevel === 1) {
            return true;
        }
        return (basicInitiatorTypes.indexOf(entry.initiatorType) >= 0 ||
            entry.entryType === 'navigation');
    }
    _logActivity(schema, payload, activityId, errorCount) {
        const startOptions = {
            id: activityId
        };
        const stopOptions = {
            perfStartOverride: payload.startTime,
            perfStopOverride: payload.startTime + payload.duration,
            errorCount
        };
        this._instr
            .startActivity(this._logPerformanceActivityName, startOptions)
            .stop(schema, payload, stopOptions);
    }
    _logPerformanceEntries(list) {
        for (const entry of list.getEntriesByType('navigation')) {
            const nt = entry;
            if (this._shouldInclude(nt)) {
                if (nt !== this._navTiming) {
                    this._navTiming = nt;
                    const payload = this._resourceEntryToResourceTiming(nt);
                    const navOnly = {
                        domComplete: nt.domComplete,
                        domContentLoadedEventStart: nt.domContentLoadedEventStart,
                        domContentLoadedEventEnd: nt.domContentLoadedEventEnd,
                        domInteractive: nt.domInteractive,
                        loadEventStart: nt.loadEventStart,
                        loadEventEnd: nt.loadEventEnd,
                        redirectCount: nt.redirectCount,
                        type: nt.type,
                        unloadEventStart: nt.unloadEventStart,
                        unloadEventEnd: nt.unloadEventEnd
                    };
                    this._logActivity(navigation_timing, Object.assign(payload, navOnly));
                }
                break;
            }
        }
        for (const entry of list.getEntriesByType('resource')) {
            const rt = entry;
            const requestInfo = this._fuzzyMapper.pop(rt.name, rt.startTime);
            if (this._shouldInclude(rt)) {
                const payload = this._resourceEntryToResourceTiming(rt);
                Object.assign(payload, {
                    srvReqId: requestInfo === null || requestInfo === void 0 ? void 0 : requestInfo.requestId,
                    xhrDelay: requestInfo ? requestInfo.activityDuration - rt.duration : undefined
                });
                this._logActivity(resource_timing, payload, requestInfo === null || requestInfo === void 0 ? void 0 : requestInfo.activityId, requestInfo === null || requestInfo === void 0 ? void 0 : requestInfo.errorCount);
            }
        }
    }
}

const defaultTraceIdLengthW3 = 32;
const defaultTraceIdLengthB3 = 16;
const defaultSpanIdLength = 16;
const headerTraceParent = 'traceparent';
const headerB3 = 'b3';
const headerTraceId = 'X-B3-TraceId';
const headerSpanId = 'X-B3-SpanId';
const headerSampled = 'X-B3-Sampled';
const headerParentSpanId = 'X-B3-ParentSpanId';
const headerRequestId = 'X-SFDC-Request-Id';
const defaultActivityNameForFetch = 'fetch';
const defaultActivityNameForXhrSend = 'xhr_send';
const defaultTimingActivityName = 'perf-timing';
const defaultFuzzyMapRange = 50;
class Tracing {
    constructor(_instr, _idleDetector) {
        this._instr = _instr;
        this._idleDetector = _idleDetector;
        utility.requireArgument(_instr, '_instr', 'object');
        utility.requireArgument(_idleDetector, '_idleDetector', 'object');
    }
    static _getB3CompactFormat(traceId, spanId, isSampled, parentSpanId) {
        let b3 = `${traceId}-${spanId}`;
        if (isSampled !== undefined || parentSpanId !== undefined) {
            b3 += isSampled ? '-1' : '-0';
            if (parentSpanId !== undefined) {
                b3 += `-${parentSpanId}`;
            }
        }
        return b3;
    }
    static _getW3CompactFormat(traceId, spanId, isSampled) {
        return `00-${traceId}-${spanId}-${isSampled ? '01' : '00'}`;
    }
    static _conformTextAsId(text, numChars) {
        text = text.toLowerCase();
        const len = text.length;
        for (let i = 0; i < len; i += 1) {
            const c = text[i];
            if (!(c >= 'a' && c <= 'f') && !(c >= '0' && c <= '9')) {
                throw new Error(`The text '${text}' has an invalid character at index #${i}`);
            }
        }
        if (len > numChars) {
            return text.substr(len - numChars);
        }
        if (len < numChars) {
            return text.padStart(numChars, '0');
        }
        return text;
    }
    static getHeaders(traceId, spanId, isSampled, options) {
        utility.requireArgument(traceId, 'traceId', 'string');
        utility.requireArgument(spanId, 'spanId', 'string');
        const useB3Headers = options === null || options === void 0 ? void 0 : options.useB3Headers;
        traceId = this._conformTextAsId(traceId, (options === null || options === void 0 ? void 0 : options.traceIdEffectiveLength) !== undefined
            ? options.traceIdEffectiveLength
            : useB3Headers
                ? defaultTraceIdLengthB3
                : defaultTraceIdLengthW3);
        spanId = this._conformTextAsId(spanId, defaultSpanIdLength);
        const parentSpanId = (options &&
            options.parentSpanId !== undefined &&
            this._conformTextAsId(options.parentSpanId, defaultSpanIdLength)) ||
            undefined;
        const headers = {};
        if (useB3Headers) {
            const isCompact = options === null || options === void 0 ? void 0 : options.useCompactHeader;
            if (isCompact) {
                headers[headerB3] = this._getB3CompactFormat(traceId, spanId, isSampled, parentSpanId);
            }
            else {
                headers[headerTraceId] = traceId;
                headers[headerSpanId] = spanId;
                if (parentSpanId !== undefined) {
                    headers[headerParentSpanId] = parentSpanId;
                }
                if (isSampled !== undefined) {
                    headers[headerSampled] = isSampled ? '1' : '0';
                }
            }
        }
        else {
            headers[headerTraceParent] = this._getW3CompactFormat(traceId, spanId, isSampled);
        }
        return headers;
    }
    _disableNetworkInstrumentation() {
        if (Tracing._isNetworkInstrumentationEnabled) {
            if (Tracing._originalFetch) {
                Tracing._global.fetch = Tracing._originalFetch;
                Tracing._originalFetch = undefined;
            }
            if (Tracing._originalXhr) {
                Tracing._global.XMLHttpRequest = Tracing._originalXhr;
                Tracing._originalXhr = undefined;
            }
            if (Tracing._originalXhrOpen) {
                Tracing._global.XMLHttpRequest.prototype.open = Tracing._originalXhrOpen;
                Tracing._originalXhrOpen = undefined;
            }
            if (Tracing._originalXhrSetRequestHeader) {
                Tracing._global.XMLHttpRequest.prototype.setRequestHeader =
                    Tracing._originalXhrSetRequestHeader;
                Tracing._originalXhrSetRequestHeader = undefined;
            }
            if (Tracing._originalXhrSend) {
                Tracing._global.XMLHttpRequest.prototype.send = Tracing._originalXhrSend;
                Tracing._originalXhrSend = undefined;
            }
            if (Tracing._performanceObservability) {
                Tracing._performanceObservability.stop();
                Tracing._performanceObservability = undefined;
            }
            Tracing._isNetworkInstrumentationEnabled = false;
        }
    }
    _enableNetworkInstrumentation(instr, logErrors, activityName, useTracing, options, tasker, logPerformance, logPerformanceActivityName, skipUrls, fuzzyMapRange) {
        if (typeof Tracing._global.fetch === 'function') {
            this._overrideFetch(instr, logErrors, activityName, useTracing, options, tasker);
            Tracing._isNetworkInstrumentationEnabled = true;
        }
        if (typeof Tracing._global.XMLHttpRequest === 'function') {
            this._overrideXhr(instr, logErrors, activityName, useTracing, options, tasker);
            Tracing._isNetworkInstrumentationEnabled = true;
        }
        if (logPerformance) {
            Tracing._performanceObservability = new PerformanceObservability(instr, fuzzyMapRange, skipUrls, logPerformanceActivityName, logPerformance === true ? 'full' : logPerformance);
            Tracing._performanceObservability.start();
            Tracing._isNetworkInstrumentationEnabled = true;
        }
    }
    static _getTraceHeaders(activity, options, method, url) {
        let traceHeaders = (activity === null || activity === void 0 ? void 0 : activity.getTraceHeaders(options)) || {};
        if (typeof (options === null || options === void 0 ? void 0 : options.headerProcessor) === 'function') {
            traceHeaders = options.headerProcessor({
                method,
                url,
                defaultHeaders: traceHeaders
            });
        }
        else if (typeof window === 'object') {
            let newUrl;
            try {
                newUrl = new URL(url);
            }
            catch (_a) {
            }
            if (newUrl && newUrl.host !== window.location.host) {
                traceHeaders = undefined;
            }
        }
        return traceHeaders || {};
    }
    static _extractHeader(headerName, input, init) {
        if ((init === null || init === void 0 ? void 0 : init.headers) instanceof Headers) {
            return init.headers.get(headerName);
        }
        if (Array.isArray(init === null || init === void 0 ? void 0 : init.headers)) {
            const header = init.headers.find((entry) => entry[0] === headerName);
            return header === null || header === void 0 ? void 0 : header[1];
        }
        if (typeof (init === null || init === void 0 ? void 0 : init.headers) === 'object') {
            return init.headers[headerName];
        }
        if (input instanceof Request) {
            return input.headers.get(headerName);
        }
        return undefined;
    }
    _overrideFetch(instr, logErrors, activityName, useTracing, tracingHeadersOptions, tasker) {
        Tracing._originalFetch = Tracing._global.fetch;
        const o11yFetch = async (resource, options, ...restArgs) => {
            var _a;
            let activity;
            let url;
            let absoluteUrl;
            let method;
            let fetchTime;
            try {
                tasker === null || tasker === void 0 ? void 0 : tasker.add();
                method = options === null || options === void 0 ? void 0 : options.method;
                const ofo = options === null || options === void 0 ? void 0 : options.o11y;
                if (!(ofo === null || ofo === void 0 ? void 0 : ofo.skipInstr)) {
                    activity = instr.startActivity(activityName || defaultActivityNameForFetch);
                }
                else {
                    Tracing._reqIndex += 1;
                    try {
                        if (resource instanceof URL) {
                            resource.searchParams.append('o11y', Tracing._reqIndex.toString());
                        }
                        else if (typeof resource === 'string') {
                            const urlObj = new URL(resource);
                            const kv = `o11y=${Tracing._reqIndex}`;
                            urlObj.search += urlObj.search.startsWith('?') ? `&${kv}` : kv;
                            resource = urlObj.toString();
                        }
                    }
                    catch (_b) { }
                }
                options === null || options === void 0 ? true : delete options.o11y;
                url = resource === null || resource === void 0 ? void 0 : resource.toString();
                absoluteUrl = utility.tryGetAbsoluteUrl(url);
                if (useTracing) {
                    if (resource instanceof Request) {
                        if (!method) {
                            method = resource.method;
                        }
                        url = resource.url;
                        absoluteUrl = utility.tryGetAbsoluteUrl(url);
                    }
                    const traceHeaders = Tracing._getTraceHeaders(activity, tracingHeadersOptions, method, absoluteUrl);
                    if (!this._applyTraceHeaders(resource, options, traceHeaders) &&
                        options === undefined) {
                        options = {
                            headers: traceHeaders
                        };
                    }
                }
                fetchTime = utility.perfNow();
                return await Tracing._originalFetch.call(Tracing._global, resource, options, ...restArgs);
            }
            catch (ex) {
                if (logErrors) {
                    if (activity) {
                        activity.error(ex);
                    }
                    else {
                        instr.error(ex);
                    }
                }
                throw ex;
            }
            finally {
                try {
                    const activityDuration = Tracing._endActivity(activity, url, method);
                    if ((_a = Tracing._performanceObservability) === null || _a === void 0 ? void 0 : _a.isStarted) {
                        const requestId = Tracing._extractHeader(headerRequestId, resource, options);
                        Tracing._performanceObservability.addEntry(absoluteUrl, fetchTime, {
                            requestId,
                            activityDuration,
                            activityId: activity === null || activity === void 0 ? void 0 : activity.getId(),
                            errorCount: activity === null || activity === void 0 ? void 0 : activity.getErrorCount()
                        });
                    }
                }
                finally {
                    tasker === null || tasker === void 0 ? void 0 : tasker.done();
                }
            }
        };
        Tracing._global.fetch = o11yFetch;
    }
    static _endActivity(activity, url, method) {
        var _a;
        if (activity) {
            if ((_a = Tracing._performanceObservability) === null || _a === void 0 ? void 0 : _a.isStarted) {
                activity.discard();
            }
            else {
                activity.stop(networkSchema, {
                    mtd: method,
                    url
                });
            }
            return activity.getStopPerfTime() - activity.getStartPerfTime();
        }
        return undefined;
    }
    _overrideXhr(instr, logErrors, activityName, useTracing, options, tasker) {
        Tracing._originalXhr = Tracing._global.XMLHttpRequest;
        Tracing._originalXhrOpen = Tracing._originalXhr.prototype.open;
        Tracing._originalXhrSetRequestHeader = Tracing._originalXhr.prototype.setRequestHeader;
        Tracing._originalXhrSend = Tracing._originalXhr.prototype.send;
        function postProcess(xhr, failedAtInit) {
            var _a;
            if (xhr._o11y) {
                const activity = xhr._o11y.activity;
                const activityDuration = Tracing._endActivity(activity, xhr._o11y.url, xhr._o11y.method);
                if (!failedAtInit && ((_a = Tracing._performanceObservability) === null || _a === void 0 ? void 0 : _a.isStarted)) {
                    Tracing._performanceObservability.addEntry(xhr._o11y.absoluteUrl, xhr._o11y.sendTime, {
                        requestId: xhr._o11y.requestId,
                        activityDuration,
                        activityId: activity === null || activity === void 0 ? void 0 : activity.getId(),
                        errorCount: activity === null || activity === void 0 ? void 0 : activity.getErrorCount()
                    });
                }
            }
        }
        Tracing._originalXhr.prototype.open = function (method, url, __async, __username, __password) {
            this._o11y = {
                method,
                url: url === null || url === void 0 ? void 0 : url.toString()
            };
            this._o11y.absoluteUrl = utility.tryGetAbsoluteUrl(this._o11y.url);
            Tracing._originalXhrOpen.apply(this, arguments);
        };
        Tracing._originalXhr.prototype.setRequestHeader = function (name, value) {
            var _a;
            if (((_a = name === null || name === void 0 ? void 0 : name.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(name)) === headerRequestId.toLowerCase()) {
                this._o11y.requestId = value;
            }
            Tracing._originalXhrSetRequestHeader.apply(this, arguments);
        };
        Tracing._originalXhr.prototype.send = function (...args) {
            let activity;
            const xhr = this;
            try {
                tasker === null || tasker === void 0 ? void 0 : tasker.add();
                xhr._o11y = xhr._o11y || {};
                xhr._o11y.activity = activity = instr.startActivity(activityName || defaultActivityNameForXhrSend);
                if (useTracing) {
                    const traceHeaders = Tracing._getTraceHeaders(activity, options, xhr._o11y.method, xhr._o11y.absoluteUrl);
                    Object.entries(traceHeaders).forEach((entry) => {
                        xhr.setRequestHeader(entry[0], entry[1]);
                    });
                }
                xhr._o11y.sendTime = utility.perfNow();
                Tracing._originalXhrSend.call(this, ...args);
            }
            catch (ex) {
                if (logErrors) {
                    if (activity) {
                        activity.error(ex);
                    }
                    else {
                        instr.error(ex);
                    }
                }
                postProcess(xhr, true);
                tasker === null || tasker === void 0 ? void 0 : tasker.done();
                throw ex;
            }
        };
        const xhrProxy = new Proxy(Tracing._originalXhr, {
            construct(target) {
                const newXhr = new target();
                newXhr.addEventListener('load', () => {
                    postProcess(newXhr);
                    tasker === null || tasker === void 0 ? void 0 : tasker.done();
                });
                newXhr.addEventListener('error', (__err) => {
                    var _a;
                    try {
                        const error = new Error('XHR Network-Level Error');
                        if (logErrors) {
                            const activity = (_a = newXhr._o11y) === null || _a === void 0 ? void 0 : _a.activity;
                            if (activity) {
                                activity.error(error);
                            }
                            else {
                                instr.error(error);
                            }
                        }
                        postProcess(newXhr);
                    }
                    finally {
                        tasker === null || tasker === void 0 ? void 0 : tasker.done();
                    }
                });
                newXhr.addEventListener('abort', () => {
                    var _a, _b;
                    (_b = (_a = newXhr._o11y) === null || _a === void 0 ? void 0 : _a.activity) === null || _b === void 0 ? void 0 : _b.discard();
                    tasker === null || tasker === void 0 ? void 0 : tasker.done();
                });
                return newXhr;
            }
        });
        Tracing._global.XMLHttpRequest = xhrProxy;
    }
    networkInstrumentation(options) {
        var _a;
        utility.requireArgument(options, 'options', ['boolean', 'object']);
        this._disableNetworkInstrumentation();
        if (options) {
            const tracingOptions = typeof options === 'object' ? options : {};
            let tasker = undefined;
            if (utility.definedValueOrDefault(tracingOptions.useTasker, true)) {
                tasker = (_a = this._idleDetector) === null || _a === void 0 ? void 0 : _a.declareNotifierTaskMulti('o11y network');
            }
            this._enableNetworkInstrumentation(utility.definedValueOrDefault(tracingOptions.instrumentation, this._instr), utility.definedValueOrDefault(tracingOptions.logErrors, true), tracingOptions.activityName, utility.definedValueOrDefault(tracingOptions.useTracing, true), tracingOptions.tracingHeadersOptions, tasker, utility.definedValueOrDefault(tracingOptions.logPerformance, true), utility.definedValueOrDefault(tracingOptions.logPerformanceActivityName, defaultTimingActivityName), utility.definedValueOrDefault(tracingOptions.skipUrls, []), utility.definedValueOrDefault(tracingOptions.fuzzyMapRange, defaultFuzzyMapRange));
        }
    }
    resetRequestCounter() {
        Tracing._reqIndex = 0;
    }
    _applyTraceHeaders(resource, options, traceHeaders) {
        if ((options === null || options === void 0 ? void 0 : options.headers) !== undefined) {
            if (options.headers instanceof Headers && typeof options.headers.set === 'function') {
                Object.entries(traceHeaders).forEach(([key, value]) => {
                    options.headers.set(key, value);
                });
                return true;
            }
            if (Array.isArray(options.headers)) {
                Object.entries(traceHeaders).forEach((entry) => {
                    options.headers.push(entry);
                });
                return true;
            }
            if (typeof options.headers === 'object') {
                options.headers = Object.assign(options.headers, traceHeaders);
                return true;
            }
        }
        else if (resource instanceof Request && resource.headers instanceof Headers) {
            Object.entries(traceHeaders).forEach(([key, value]) => {
                resource.headers.set(key, value);
            });
            return true;
        }
        else if (options) {
            options.headers = Object.assign({}, traceHeaders);
            return true;
        }
        return false;
    }
}
Tracing._global = utility.getGlobal();
Tracing._isNetworkInstrumentationEnabled = false;
Tracing._reqIndex = 0;

var TimerOverride;
(function (TimerOverride) {
    TimerOverride[TimerOverride["none"] = 0] = "none";
    TimerOverride[TimerOverride["start"] = 1] = "start";
    TimerOverride[TimerOverride["stop"] = 2] = "stop";
    TimerOverride[TimerOverride["both"] = 3] = "both";
})(TimerOverride || (TimerOverride = {}));

const timedout = 'timedout';
const terminated = 'terminated';
const discarded = 'discarded';
const stopReason = {
    timedout,
    terminated,
    discarded
};
class ActivityImpl {
    constructor(_name, _rootId, _onStopped, _onError, timeout, id, _isSampled, _startPerfTime, _noRerooting) {
        this._name = _name;
        this._rootId = _rootId;
        this._onStopped = _onStopped;
        this._onError = _onError;
        this._isSampled = _isSampled;
        this._noRerooting = _noRerooting;
        this._errorCount = 0;
        this._timerOverridden = TimerOverride.none;
        const { tsNow, perfNow } = utility.time();
        ActivityImpl._count += 1;
        this._id = id || utility.generateUniqueId();
        this._usePerf =
            typeof performance !== 'undefined' &&
                typeof performance.mark === 'function' &&
                typeof performance.measure === 'function';
        if (this._usePerf) {
            this._perfName = `${this._name}__${ActivityImpl._count}`;
            this._perfId = `${this._name}__${this.id}`;
            try {
                performance.mark(this._perfId);
            }
            catch (_a) {
                this._usePerf = false;
            }
        }
        this._startTimestamp = tsNow;
        this._startPerfTime = perfNow;
        this._overrideTimer(_startPerfTime);
        if (timeout > 0) {
            this._timer = setTimeout(() => {
                this._stopReason = this._stopReason || stopReason.timedout;
                this.stop();
            }, timeout);
        }
        this._safety = new PublicSafety();
    }
    get id() {
        return this._id;
    }
    getId() {
        return this.id;
    }
    getRootId() {
        return this._rootId;
    }
    get stopReason() {
        return this._stopReason;
    }
    error(error, userSchemaOrText, userData) {
        this._safety.tryCatch(() => {
            this._errorCount += 1;
            if (typeof error === 'string') {
                error = new Error(error);
            }
            this._onError(error, this._getDetail(userSchemaOrText, userData));
        }, { op: 'activity.error' });
    }
    stop(userSchemaOrText, userData, options) {
        this._safety.tryCatch(() => {
            utility.requireArgumentIfDefined(userSchemaOrText, 'userSchemaOrText', [
                'object',
                'string'
            ]);
            utility.requireArgumentIfDefined(userData, 'userData', 'object');
            if (options) {
                const perfStart = options.perfStartOverride;
                const isStartTimeDefined = utility.requireArgumentIfDefined(perfStart, 'options.perfStartOverride', 'number');
                const perfStop = options.perfStopOverride;
                const isStopTimeDefined = utility.requireArgumentIfDefined(perfStop, 'options.perfStopOverride', 'number');
                const errorCount = options.errorCount;
                if (utility.requireArgumentIfDefined(errorCount, 'options.errorCount', 'number')) {
                    this._errorCount = errorCount;
                }
                if (isStartTimeDefined && perfStart < 0) {
                    throw new Error('perfStartOverride, if defined, must be >= 0');
                }
                if (isStopTimeDefined &&
                    (perfStop < 0 ||
                        perfStop < (isStartTimeDefined ? perfStart : this._startPerfTime) ||
                        perfStop > utility.time().perfNow + 100)) {
                    throw new Error('perfStopOverride, if defined, must be >= 0 and >= startTime and <= now');
                }
            }
            this._stopInternal(userSchemaOrText, userData, options);
        }, { op: 'activity.stop' });
    }
    _overrideTimer(perfStartTime, perfStopTime) {
        if (perfStartTime !== undefined) {
            this._startTimestamp = Math.round(this._startTimestamp - (this._startPerfTime - perfStartTime));
            this._startPerfTime = perfStartTime;
            this._setTimerOverride(TimerOverride.start);
        }
        if (perfStopTime !== undefined) {
            this._stopPerfTime = perfStopTime;
            this._setTimerOverride(TimerOverride.stop);
        }
    }
    _setTimerOverride(value) {
        if (this._timerOverridden === TimerOverride.both ||
            this._timerOverridden === value ||
            value === TimerOverride.none) {
            return;
        }
        this._timerOverridden =
            this._timerOverridden === TimerOverride.none ? value : TimerOverride.both;
    }
    _stopInternal(userSchemaOrText, userData, options) {
        const stopPerfTime = utility.perfNow();
        if (this._usePerf) {
            try {
                if (this._stopReason !== stopReason.discarded) {
                    performance.measure(this._perfName, this._perfId);
                }
                performance.clearMarks(this._perfId);
                performance.clearMeasures(this._perfName);
            }
            catch (_a) { }
        }
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
        if (this.isStopped) {
            return;
        }
        if (options) {
            this._overrideTimer(options.perfStartOverride, options.perfStopOverride);
        }
        this._stopPerfTime =
            this._timerOverridden === TimerOverride.none ||
                this._timerOverridden === TimerOverride.start
                ? stopPerfTime
                : this._stopPerfTime;
        const activityDetail = this._getDetail(userSchemaOrText, userData);
        this._onStopped(activityDetail);
    }
    get isStopped() {
        return this._stopPerfTime !== undefined;
    }
    discard() {
        this._safety.tryCatch(() => {
            this._stopReason = this._stopReason || stopReason.discarded;
            this.stop();
        }, { op: 'activity.discard' });
    }
    terminate(userSchemaOrText, userData, options) {
        this._safety.tryCatch(() => {
            this._stopReason = this._stopReason || stopReason.terminated;
            this.stop(userSchemaOrText, userData, options);
        }, { op: 'activity.terminate' });
    }
    getIsSampled() {
        return this._isSampled || false;
    }
    _getDetail(userSchemaOrText, userData) {
        return {
            id: this._id,
            rootId: this._rootId,
            name: this._name,
            userSchemaOrText: userSchemaOrText,
            userData,
            stopReason: this._stopReason,
            startTimestamp: this._startTimestamp,
            startPerfTime: this._startPerfTime,
            stopPerfTime: this._stopPerfTime,
            errorCount: this._errorCount,
            isSampled: this.getIsSampled(),
            timerOverridden: this._timerOverridden,
            noRerooting: this._noRerooting
        };
    }
    getTraceHeaders(options) {
        const spanId = this.id;
        const traceId = this._rootId || spanId;
        return Tracing.getHeaders(traceId, spanId, this.getIsSampled(), options);
    }
    getStartTimestamp() {
        return this._startTimestamp;
    }
    getStartPerfTime() {
        return this._startPerfTime;
    }
    getStopPerfTime() {
        return this._stopPerfTime;
    }
    getErrorCount() {
        return this._errorCount;
    }
}
ActivityImpl._count = 0;

const id = new Array(16).fill(0).join('');
class ActivityNoOp {
    getId() {
        return id;
    }
    getRootId() {
        return undefined;
    }
    error() { }
    stop() { }
    discard() { }
    terminate() { }
    getIsSampled() {
        return false;
    }
    getTraceHeaders(__options) {
        return {};
    }
    getStartTimestamp() {
        return undefined;
    }
    getStartPerfTime() {
        return undefined;
    }
    getStopPerfTime() {
        return undefined;
    }
    getErrorCount() {
        return 0;
    }
}
const activityNoOp = Object.freeze(new ActivityNoOp());

class DomEventHelpers {
    getInstrumentedEventData(domEventDataField, domEventData, handledBy, userPayload) {
        var _a;
        const instrumentedEvent = {
            ownerComponent: handledBy.tagName,
            parentComponent: ((_a = handledBy.parentElement) === null || _a === void 0 ? void 0 : _a.tagName) || undefined,
            simplePath: utility.getXpath(handledBy)
        };
        switch (domEventDataField) {
            case 0:
                instrumentedEvent.baseEvent = domEventData;
                break;
            case 1:
                instrumentedEvent.mouseEvent = domEventData;
                break;
        }
        if (userPayload) {
            instrumentedEvent.userPayload = schemaUtil.makePayload(userPayload.schema, userPayload.payload, true);
        }
        return instrumentedEvent;
    }
    getEventData(e) {
        return {
            type: e.type
        };
    }
    getMouseEventData(e) {
        return {
            altKey: e.altKey,
            bubbles: e.bubbles,
            button: e.button,
            buttons: e.buttons,
            cancelable: e.cancelable,
            clientX: e.clientX,
            clientY: e.clientY,
            composed: e.composed,
            defaultPrevented: e.defaultPrevented,
            detail: e.detail,
            eventPhase: e.eventPhase,
            isTrusted: e.isTrusted,
            timeStamp: e.timeStamp,
            type: e.type,
            ctrlKey: e.ctrlKey,
            metaKey: e.metaKey,
            movementX: e.movementX,
            movementY: e.movementY,
            offsetX: e.offsetX,
            offsetY: e.offsetY,
            pageX: e.pageX,
            pageY: e.pageY,
            screenX: e.screenX,
            screenY: e.screenY,
            shiftKey: e.shiftKey
        };
    }
}
const singleton = new DomEventHelpers();
const domEventHelpers = singleton;

class BucketHistogramImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags, _buckets, createdOn, lastUpdatedOn, values) {
        this._name = _name;
        this._ownerName = _ownerName;
        this._ownerAppName = _ownerAppName;
        this._tags = _tags;
        this._buckets = _buckets;
        this._values = new Array();
        this._createdOn = createdOn === undefined ? utility.time().tsNow : createdOn;
        if (lastUpdatedOn !== undefined) {
            this._lastUpdatedOn = lastUpdatedOn;
        }
        if (values !== undefined) {
            this._values = values;
        }
    }
    getName() {
        return this._name;
    }
    getCreatedOn() {
        return this._createdOn;
    }
    getLastUpdatedOn() {
        return this._lastUpdatedOn;
    }
    getData() {
        return this.values;
    }
    getBuckets() {
        return this.buckets;
    }
    get buckets() {
        return this._buckets.slice(0, this._buckets.length);
    }
    get values() {
        return this._values.slice(0, this._values.length);
    }
    record(value) {
        if (typeof value === 'number') {
            this._values.push(value);
            this._lastUpdatedOn = utility.time().tsNow;
            return;
        }
        throw new Error('BucketHistogram can only record numbers.');
    }
    reset() {
        this._lastUpdatedOn = undefined;
        this._values = [];
    }
    getOwnerName() {
        return this._ownerName;
    }
    getOwnerAppName() {
        return this._ownerAppName;
    }
    getTags() {
        return this._tags;
    }
}

class ValueRecorderImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags, createdOn, lastUpdatedOn, values) {
        this._name = _name;
        this._ownerName = _ownerName;
        this._ownerAppName = _ownerAppName;
        this._tags = _tags;
        this._values = new Array();
        this._createdOn = createdOn === undefined ? utility.time().tsNow : createdOn;
        if (lastUpdatedOn !== undefined) {
            this._lastUpdatedOn = lastUpdatedOn;
        }
        if (values !== undefined) {
            this._values = values;
        }
    }
    getName() {
        return this._name;
    }
    getCreatedOn() {
        return this._createdOn;
    }
    getLastUpdatedOn() {
        return this._lastUpdatedOn;
    }
    getData() {
        return this.values;
    }
    get values() {
        return this._values.slice(0, this._values.length);
    }
    record(value) {
        if (typeof value === 'number') {
            this._values.push(value);
            this._lastUpdatedOn = utility.time().tsNow;
            return;
        }
        throw new Error('ValueRecorder can only record numbers.');
    }
    reset() {
        this._lastUpdatedOn = undefined;
        this._values = [];
    }
    getOwnerName() {
        return this._ownerName;
    }
    getOwnerAppName() {
        return this._ownerAppName;
    }
    getTags() {
        return this._tags;
    }
}

class SizeLimitedMap {
    constructor(maxSize) {
        this._map = new Map();
        if (typeof maxSize === 'number' && maxSize > 0) {
            this._maxSize = Math.ceil(maxSize);
            return;
        }
        throw new Error('maxSize must be a positive number');
    }
    get maxSize() {
        return this._maxSize;
    }
    get(key) {
        return this._map.get(key);
    }
    has(key) {
        return this._map.has(key);
    }
    set(key, value) {
        if (this.has(key) || this._map.size < this.maxSize) {
            this._map.set(key, value);
            return true;
        }
        return false;
    }
    getElements() {
        return Array.from(this._map.values());
    }
    clear() {
        this._map.clear();
    }
}

const maxCounters = 1000;
const maxValueRecorders = 500;
const maxBucketHistograms = 500;
var MetricType;
(function (MetricType) {
    MetricType[MetricType["Counter"] = 0] = "Counter";
    MetricType[MetricType["Percentile"] = 1] = "Percentile";
    MetricType[MetricType["BucketHistogram"] = 2] = "BucketHistogram";
})(MetricType || (MetricType = {}));
class MetricsImpl {
    constructor(_ownerName, _getOwnerAppName) {
        this._ownerName = _ownerName;
        this._getOwnerAppName = _getOwnerAppName;
        this._upCounters = new SizeLimitedMap(maxCounters);
        this._valueRecorders = new SizeLimitedMap(maxValueRecorders);
        this._bucketHistograms = new SizeLimitedMap(maxBucketHistograms);
    }
    incrementCounter(operation, increment, hasError = false, tags = {}) {
        this._tagError(tags, hasError);
        this._upCounter(operation, tags).increment(increment);
    }
    trackValue(operation, value, hasError = false, tags = {}) {
        this._tagError(tags, hasError);
        this._valueRecorder(operation, tags).record(value);
    }
    bucketValue(operation, value, buckets, hasError = false, tags = {}) {
        this._tagError(tags, hasError);
        this._bucketHistogram(operation, tags, buckets).record(value);
    }
    _bucketHistogram(name, tags, buckets) {
        const { key, sortedTags } = this._getKeyAndSortedTags(name, tags, MetricType.BucketHistogram);
        let instrument = this._bucketHistograms.get(key);
        if (!instrument) {
            instrument = new BucketHistogramImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags, buckets);
            if (!this._bucketHistograms.set(key, instrument)) {
                throw new Error(`Max size of ${maxBucketHistograms} exceeded for BucketHistograms`);
            }
        }
        return instrument;
    }
    _upCounter(name, tags) {
        const { key, sortedTags } = this._getKeyAndSortedTags(name, tags, MetricType.Counter);
        let instrument = this._upCounters.get(key);
        if (!instrument) {
            instrument = new UpCounterImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags);
            if (!this._upCounters.set(key, instrument)) {
                throw new Error(`Max size of ${maxCounters} exceeded for UpCounters`);
            }
        }
        return instrument;
    }
    _valueRecorder(name, tags) {
        const { key, sortedTags } = this._getKeyAndSortedTags(name, tags, MetricType.Percentile);
        let instrument = this._valueRecorders.get(key);
        if (!instrument) {
            instrument = new ValueRecorderImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags);
            if (!this._valueRecorders.set(key, instrument)) {
                throw new Error(`Max size of ${maxValueRecorders} exceeded for ValueRecorders`);
            }
        }
        return instrument;
    }
    getUpCounters() {
        return this._upCounters.getElements();
    }
    getValueRecorders() {
        return this._valueRecorders.getElements();
    }
    getBucketHistograms() {
        return this._bucketHistograms.getElements();
    }
    _tagError(tags, hasError) {
        tags.status = hasError === true ? 'error' : 'success';
    }
    _getKeyAndSortedTags(operation, tags, metricType) {
        const sortedTags = Object.keys(tags)
            .sort()
            .reduce((prev, curr) => {
            prev[curr] = tags[curr];
            return prev;
        }, {});
        const key = `${MetricType[metricType]}:${operation}${JSON.stringify(sortedTags)}`;
        return {
            key,
            sortedTags
        };
    }
}

class MockBase {
    constructor() {
        this.isMock = true;
    }
}

const maxActivityDurationMsecs = undefined;
const reservedMetricCharacters = ['`'];
const reservedMetricNames = {
    internalError: 'o11y-error'
};
const denyListMetricNames = Object.freeze(Array.from(Object.values(reservedMetricNames)));
class InstrumentationImpl {
    constructor(_nextGen, _name) {
        this._nextGen = _nextGen;
        this._name = _name;
        this._onActivityStoppedCallback = this._handleActivityStop.bind(this);
        this._onActivityErrorCallback = this._handleActivityError.bind(this);
        for (const reservedChar of reservedMetricCharacters) {
            if (this._name.indexOf(reservedChar) >= 0) {
                throw new Error(`Name cannot include the reserved character "${reservedChar}"`);
            }
        }
        this._safety = new PublicSafety({
            increment: (increment) => this._incrementError(increment)
        });
        this._metrics = this._initMetrics();
        const simpleTextOptions = schemaUtil.getOptions(simpleSchema, 'Simple', 'text');
        this._simpleTextMaxLength = simpleTextOptions
            ? simpleTextOptions['(meta.max_length)']
            : maxStringLengthAppLimit;
    }
    _initMetrics() {
        return new MetricsImpl(this.name, () => this._nextGen.appName || InstrumentationImpl.defaultAppName);
    }
    _incrementError(increment = 1) {
        this._metrics.incrementCounter(reservedMetricNames.internalError, increment, true);
    }
    get name() {
        return this._name;
    }
    _wrapUserPayload(userSchemaOrText, userData, onlyIfBoth = false) {
        let userSchema;
        if (typeof userSchemaOrText === 'string') {
            userSchema = simpleSchema;
            if (userSchemaOrText) {
                userData = {
                    text: userSchemaOrText.substring(0, this._simpleTextMaxLength)
                };
            }
            else {
                userData = undefined;
            }
        }
        else {
            userSchema = userSchemaOrText;
        }
        return schemaUtil.makePayload(userSchema, userData, onlyIfBoth);
    }
    _getEffectiveRootId(options) {
        var _a, _b;
        return ((_b = (_a = options === null || options === void 0 ? void 0 : options.instrumentationContext) === null || _a === void 0 ? void 0 : _a.rootId) !== null && _b !== void 0 ? _b : this._nextGen.getDefaultInstrumentationContext().rootId);
    }
    log(userSchemaOrText, userData, options) {
        this._safety.tryCatch(() => {
            const timestamp = utility.time().tsNow;
            utility.requireArgument(userSchemaOrText, 'userSchemaOrText', ['object', 'string']);
            utility.requireArgumentIfDefined(userData, 'userData', 'object');
            utility.requireArgumentIfDefined(options, 'options', 'object');
            const userPayload = this._wrapUserPayload(userSchemaOrText, userData);
            if (userPayload === null || userPayload === void 0 ? void 0 : userPayload.payload) {
                this._logInternal(this.name, userPayload.schema, userPayload.payload, timestamp, this._getEffectiveRootId(options));
            }
        }, { op: 'log' });
    }
    _logInternal(loggerName, schema, data, timestamp, rootId) {
        const sequence = this._nextGen.addLog(loggerName, schema, data, timestamp, rootId);
        if (!utility.isProduction) {
            const extraFields = payloadUtility.getExtraFields(schema, data);
            if (!utility.isProduction && extraFields.length > 0) {
                this.error('Extra fields', payloadDiagsSchema, {
                    extras: extraFields
                });
            }
        }
        return sequence;
    }
    error(error, userSchemaOrText, userData, options) {
        return this._safety.tryCatch(() => {
            utility.requireArgumentIfDefined(userSchemaOrText, 'userSchemaOrText', [
                'object',
                'string'
            ]);
            utility.requireArgumentIfDefined(userData, 'userData', 'object');
            utility.requireArgumentIfDefined(options, 'options', 'object');
            const rootId = this._getEffectiveRootId(options);
            this._errorInternal(error, userSchemaOrText, userData, undefined, rootId);
        }, { op: 'error' });
    }
    _errorInternal(err, userSchemaOrText, userData, activityId, rootActivityId) {
        const loggedTimestamp = utility.time().tsNow;
        let error;
        if (err instanceof Error) {
            error = err;
        }
        else {
            let msg;
            if (err === undefined || err === null || typeof err.toString !== 'function') {
                msg = 'UNKNOWN';
            }
            else {
                msg = err.toString();
            }
            error = new Error(msg);
        }
        const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);
        const errorData = {
            name: error.name,
            message: error.message,
            stack: error.stack,
            userPayload,
            activityId
        };
        return this._logInternal(this.name, errorSchema, errorData, loggedTimestamp, rootActivityId);
    }
    startActivity(name, options) {
        return this._safety.tryCatchReturn(() => {
            var _a;
            utility.requireArgument(name, 'name');
            utility.requireArgumentIfDefined(options, 'options', 'object');
            let context;
            let noRerooting = (options === null || options === void 0 ? void 0 : options.perfStartOverride) !== undefined;
            const rootId = (_a = options === null || options === void 0 ? void 0 : options.instrumentationContext) === null || _a === void 0 ? void 0 : _a.rootId;
            if (rootId) {
                noRerooting = true;
                context = {
                    rootId,
                    isRootActivitySampled: options.instrumentationContext.isRootActivitySampled
                };
            }
            else {
                context = this._nextGen.getDefaultInstrumentationContext();
            }
            const activity = new ActivityImpl(name, context.rootId, this._onActivityStoppedCallback, this._onActivityErrorCallback, maxActivityDurationMsecs, options === null || options === void 0 ? void 0 : options.id, context.isRootActivitySampled, options === null || options === void 0 ? void 0 : options.perfStartOverride, noRerooting);
            return activity;
        }, activityNoOp, { op: 'startActivity' });
    }
    _getActivityData(detail) {
        const userPayload = this._wrapUserPayload(detail.userSchemaOrText, detail.userData, true);
        return {
            id: detail.id,
            name: detail.name,
            duration: detail.stopPerfTime - detail.startPerfTime,
            stopReason: detail.stopReason,
            userPayload,
            errorCount: detail.errorCount,
            isSampled: detail.isSampled,
            timerOverridden: detail.timerOverridden,
            isRerooted: detail.isRerooted
        };
    }
    _handleActivityStop(detail) {
        if (detail.stopReason === discarded) {
            return;
        }
        if (!detail.isRoot && !detail.noRerooting) {
            const rahe = this._nextGen.getRootActivityHistoryEntryByTime(detail.startPerfTime);
            if ((!rahe && detail.rootId !== undefined) || (rahe && detail.rootId !== rahe.id)) {
                detail.rootId = rahe === null || rahe === void 0 ? void 0 : rahe.id;
                detail.isSampled = (rahe === null || rahe === void 0 ? void 0 : rahe.isSampled) || false;
                detail.isRerooted = true;
            }
        }
        const activityData = this._getActivityData(detail);
        this._logActivity(activityData, detail.startTimestamp, detail.rootId);
    }
    _logActivity(activityData, startTimestamp, rootId) {
        this._logInternal(this.name, activitySchema, activityData, startTimestamp, rootId);
    }
    _handleActivityError(error, detail) {
        this._errorInternal(error, detail.userSchemaOrText, detail.userData, detail.id, detail.rootId);
    }
    domEvent(event, handledBy, userSchemaOrText, userData, options) {
        this._safety.tryCatch(() => {
            var _a;
            const tsNow = utility.time().tsNow;
            utility.requireArgument(event, 'event', [Event, MockBase]);
            utility.requireArgument(handledBy, 'handledBy', [HTMLElement, 'object']);
            let htmlElement;
            if (handledBy instanceof HTMLElement) {
                htmlElement = handledBy;
            }
            else {
                handledBy = handledBy;
                if (((_a = handledBy.template) === null || _a === void 0 ? void 0 : _a.host) instanceof HTMLElement) {
                    htmlElement = handledBy.template.host;
                }
                else {
                    utility.requireArgument(undefined, 'handledBy');
                }
            }
            const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);
            const rootId = this._getEffectiveRootId(options);
            switch (event.type) {
                case 'click': {
                    const mouseEvent = event;
                    const acd = this._nextGen.getClickTracker();
                    if (acd) {
                        acd.markEventHandled(mouseEvent);
                    }
                    const captureMouse = options === null || options === void 0 ? void 0 : options.captureMouseData;
                    const instrumentedEvent = domEventHelpers.getInstrumentedEventData(captureMouse
                        ? 1
                        : 0, captureMouse
                        ? domEventHelpers.getMouseEventData(mouseEvent)
                        : domEventHelpers.getEventData(mouseEvent), htmlElement, userPayload);
                    instrumentedEvent.auto = options === null || options === void 0 ? void 0 : options._auto;
                    this._logInternal(this.name, instrumentedEventSchema, instrumentedEvent, tsNow, rootId);
                    break;
                }
                default:
                    throw new Error(utility.notImplemented);
            }
        }, { op: 'domEvent' });
    }
    incrementCounter(operation, increment = 1, hasError = false, tags = {}) {
        this._safety.tryCatch(() => {
            utility.requireArgument(operation, 'operation', 'string');
            utility.checkForDenyListedValues(operation, 'operation', denyListMetricNames);
            utility.checkForReservedCharacters(operation, 'operation', reservedMetricCharacters);
            utility.requireArgument(increment, 'increment', 'number');
            utility.requireArgument(hasError, 'hasError', 'boolean');
            utility.requireArgument(tags, 'tags', 'object');
            Object.entries(tags).forEach((entry) => {
                utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, [
                    'string',
                    'number',
                    'boolean'
                ]);
            });
            this._metrics.incrementCounter(operation, increment, hasError, tags);
        }, { op: 'incrementCounter' });
    }
    trackValue(operation, value, hasError = false, tags = {}) {
        this._safety.tryCatch(() => {
            utility.requireArgument(operation, 'operation', 'string');
            utility.checkForDenyListedValues(operation, 'operation', denyListMetricNames);
            utility.checkForReservedCharacters(operation, 'operation', reservedMetricCharacters);
            utility.requireArgument(value, 'value', 'number');
            utility.requireArgument(hasError, 'hasError', 'boolean');
            utility.requireArgument(tags, 'tags', 'object');
            Object.entries(tags).forEach((entry) => {
                utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, [
                    'string',
                    'number',
                    'boolean'
                ]);
            });
            this._metrics.trackValue(operation, value, hasError, tags);
        }, { op: 'trackValue' });
    }
    bucketValue(operation, value, buckets = [], hasError = false, tags = {}) {
        this._safety.tryCatch(() => {
            utility.requireArgument(operation, 'operation', 'string');
            utility.checkForDenyListedValues(operation, 'operation', denyListMetricNames);
            utility.checkForReservedCharacters(operation, 'operation', reservedMetricCharacters);
            utility.requireArgument(value, 'value', 'number');
            utility.requireArgument(buckets, 'buckets', Array);
            Object.entries(buckets).forEach((entry) => {
                utility.requireArgument(entry[1], `Bucket value for '${entry[0]}'`, 'number');
            });
            utility.requireArgument(hasError, 'hasError', 'boolean');
            utility.requireArgument(tags, 'tags', 'object');
            Object.entries(tags).forEach((entry) => {
                utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, [
                    'string',
                    'number',
                    'boolean'
                ]);
            });
            this._metrics.bucketValue(operation, value, buckets, hasError, tags);
        }, { op: 'bucketValue' });
    }
    getUpCounters() {
        return this._metrics.getUpCounters().filter((m) => m.getLastUpdatedOn());
    }
    getValueRecorders() {
        return this._metrics.getValueRecorders().filter((m) => m.getLastUpdatedOn());
    }
    getBucketHistograms() {
        return this._metrics.getBucketHistograms().filter((m) => m.getLastUpdatedOn());
    }
    registerForLogPrompt(listener) {
        utility.requireArgument(listener, 'listener', 'function');
        this._nextGen.registerForLogPrompt(listener);
    }
    _getAsaOptions(options) {
        return options
            ? Object.assign({
                instrumentationContext: options === null || options === void 0 ? void 0 : options.instrumentationContext
            }, options.startOptions)
            : undefined;
    }
    activity(name, execute, options) {
        var _a, _b, _c, _d;
        const asaOptions = this._getAsaOptions(options);
        const act = this.startActivity(name, asaOptions);
        try {
            return execute(act);
        }
        catch (err) {
            act.error(err, (_a = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _a === void 0 ? void 0 : _a.schema, (_b = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _b === void 0 ? void 0 : _b.payload);
            throw err;
        }
        finally {
            act.stop((_c = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _c === void 0 ? void 0 : _c.schema, (_d = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _d === void 0 ? void 0 : _d.payload, options === null || options === void 0 ? void 0 : options.stopOptions);
        }
    }
    async activityAsync(name, execute, options) {
        var _a, _b, _c, _d;
        const asaOptions = this._getAsaOptions(options);
        const act = this.startActivity(name, asaOptions);
        try {
            return await execute(act);
        }
        catch (err) {
            act.error(err, (_a = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _a === void 0 ? void 0 : _a.schema, (_b = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _b === void 0 ? void 0 : _b.payload);
            throw err;
        }
        finally {
            act.stop((_c = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _c === void 0 ? void 0 : _c.schema, (_d = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _d === void 0 ? void 0 : _d.payload, options === null || options === void 0 ? void 0 : options.stopOptions);
        }
    }
}
InstrumentationImpl.defaultAppName = 'APP_NOT_REGISTERED';

const GRACE = 0.1;
const DEFAULT_LIMIT = 20;
class RootActivityHistoryImpl {
    constructor(limit) {
        this._historyMap = new Map();
        this._historyList = new Array();
        if (utility.requireArgumentIfDefined(limit, 'limit', 'number')) {
            limit = Math.ceil(limit);
            if (limit <= 0) {
                throw new Error('Limit must be a positive number');
            }
        }
        else {
            limit = DEFAULT_LIMIT;
        }
        this._graceCount = Math.max(1, Math.floor(limit * GRACE));
        this._realLimit = 1 + limit + this._graceCount;
    }
    add(entry) {
        if (this._historyMap.has(entry.id)) {
            throw new Error(`RootActivityHistoryImpl.add: entry already exists for rootId: ${entry.id}`);
        }
        this._historyMap.set(entry.id, entry);
        this._historyList.push(entry);
        if (this._historyList.length === this._realLimit) {
            const removed = this._historyList.splice(1, this._graceCount);
            removed.forEach((e) => this._historyMap.delete(e.id));
        }
    }
    get count() {
        return this._historyList.length;
    }
    findById(rootId) {
        return this._historyMap.get(rootId);
    }
    findByTime(atTime) {
        let closest;
        let closestDiff = Number.MAX_VALUE;
        for (const entry of this._historyList) {
            const startDelta = atTime - entry.startPerfTime;
            const isDuringRoot = startDelta >= 0 &&
                (entry.stopPerfTime === undefined || atTime < entry.stopPerfTime);
            if (isDuringRoot && startDelta < closestDiff) {
                closest = entry;
                closestDiff = startDelta;
            }
        }
        return closest;
    }
}

class RootActivityImpl extends ActivityImpl {
    constructor(name, onStopped, onError, rootId, isSampled, startPerfTime, generatedRootIdLength) {
        super(name, undefined, onStopped, onError, undefined, rootId || utility.generateUniqueId(generatedRootIdLength !== null && generatedRootIdLength !== void 0 ? generatedRootIdLength : 32), isSampled, startPerfTime);
    }
    get preRootId() {
        return this._preRootId;
    }
    set preRootId(value) {
        this._preRootId = value;
    }
    _getDetail(userSchema, userData) {
        const detail = super._getDetail(userSchema, userData);
        detail.isRoot = true;
        detail.preRootId = this.preRootId;
        return detail;
    }
}

const rootId = new Array(32).fill(0).join('');
class RootActivityNoOp {
    getId() {
        return rootId;
    }
    getRootId() {
        return undefined;
    }
    error() { }
    stop() { }
    discard() { }
    terminate() { }
    getIsSampled() {
        return false;
    }
    getTraceHeaders(__options) {
        return {};
    }
    getStartTimestamp() {
        return undefined;
    }
    getStartPerfTime() {
        return undefined;
    }
    getStopPerfTime() {
        return undefined;
    }
    getErrorCount() {
        return 0;
    }
}
const rootActivityNoOp = Object.freeze(new RootActivityNoOp());

class AppInstrumentationImpl extends InstrumentationImpl {
    constructor(_nextGen, _name, _allowMulti) {
        super(_nextGen, _name);
        this._allowMulti = _allowMulti;
        this._rootActivityHistory = new RootActivityHistoryImpl();
        this._onRootActivityStoppedCallback = this._handleRootActivityStop.bind(this);
    }
    startRootActivity(name, rootId, isSampled, options) {
        return this._safety.tryCatchReturn(() => {
            utility.requireArgument(name, 'name');
            if ((options === null || options === void 0 ? void 0 : options.id) !== undefined) {
                throw new Error('Cannot specify id for root activity, use rootId argument instead');
            }
            const newRootActivity = new RootActivityImpl(name, this._onRootActivityStoppedCallback, this._onActivityErrorCallback, rootId, isSampled, options === null || options === void 0 ? void 0 : options.perfStartOverride, this._nextGen.preferredRootIdLength);
            if (!this._allowMulti) {
                const entry = {
                    id: newRootActivity.getId(),
                    name,
                    startPerfTime: newRootActivity.getStartPerfTime(),
                    isSampled: newRootActivity.getIsSampled()
                };
                this._rootActivityHistory.add(entry);
                if (this._singleRootActivity && !this._singleRootActivity.isStopped) {
                    const preRootId = this._singleRootActivity.getId();
                    this._singleRootActivity.terminate();
                    newRootActivity.preRootId = preRootId;
                }
                this._singleRootActivity = newRootActivity;
            }
            return newRootActivity;
        }, rootActivityNoOp, { op: 'startRootActivity' });
    }
    _handleRootActivityStop(detail) {
        const historyEntry = this._rootActivityHistory.findById(detail.id);
        if (historyEntry) {
            historyEntry.stopPerfTime = detail.stopPerfTime;
            historyEntry.startPerfTime = detail.startPerfTime;
        }
        if (detail.stopReason === discarded) {
            return;
        }
        const activityData = this._getActivityData(detail);
        this._logActivity(activityData, detail.startTimestamp);
        this._singleRootActivity = undefined;
    }
    _getActivityData(detail) {
        const activityData = super._getActivityData(detail);
        activityData.isRoot = detail.isRoot;
        activityData.preRootId = detail.preRootId;
        return activityData;
    }
    getSingleRootActivityId() {
        var _a;
        return (_a = this._singleRootActivity) === null || _a === void 0 ? void 0 : _a.getId();
    }
    isSingleRootActivitySampled() {
        var _a;
        return (_a = this._singleRootActivity) === null || _a === void 0 ? void 0 : _a.getIsSampled();
    }
    _initMetrics() {
        return new MetricsImpl(this.name, () => this.name);
    }
    getRootActivityHistoryEntry(atTime) {
        return this._rootActivityHistory.findByTime(atTime);
    }
}

const pathLimit = 5;
class AutomaticClickTracker {
    constructor(_instr, _doc) {
        this._instr = _instr;
        this._doc = _doc;
        this._isActive = false;
        this._boundClickListener = this._clickListener.bind(this);
        utility.requireArgument(_instr, '_instr');
        utility.requireArgument(_doc, '_doc');
    }
    activate() {
        if (!this._isActive) {
            this._doc.addEventListener('click', this._boundClickListener, true);
            this._isActive = true;
        }
    }
    deactivate() {
        if (this._isActive) {
            this._doc.removeEventListener('click', this._boundClickListener, true);
            this._isActive = false;
        }
    }
    markEventHandled(event) {
        this._ignoredEvent = event;
    }
    _clickListener(event) {
        var _a;
        let eventTargets = (_a = event.composedPath) === null || _a === void 0 ? void 0 : _a.call(event);
        if (!eventTargets || !eventTargets.length) {
            eventTargets = event.path;
        }
        const handledBy = this._getClickableElement(eventTargets);
        if (handledBy) {
            setTimeout(() => {
                if (event !== this._ignoredEvent) {
                    this._instr.domEvent(event, handledBy, undefined, undefined, {
                        _auto: true
                    });
                }
            });
        }
    }
    _getClickableElement(path) {
        var _a, _b;
        const limit = path ? Math.min(path.length, pathLimit) : 0;
        for (let x = 0; x < limit; x += 1) {
            const currentElement = path[x];
            const tagName = (_a = currentElement.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (tagName === 'a' || tagName === 'button') {
                return currentElement;
            }
            if (tagName === 'input') {
                const inputElement = currentElement;
                if (((_b = inputElement.type) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'button') {
                    return inputElement;
                }
            }
        }
        return undefined;
    }
}

const MESSAGE_FROM_RECEIVER = 'o11y:receiver';
var CommState;
(function (CommState) {
    CommState[CommState["Unknown"] = 0] = "Unknown";
    CommState[CommState["Opening"] = 1] = "Opening";
})(CommState || (CommState = {}));
class ReceiverConnector {
    constructor(_logCallback, _metricsCallback, _commErrorCallback) {
        this._logCallback = _logCallback;
        this._metricsCallback = _metricsCallback;
        this._commErrorCallback = _commErrorCallback;
        this._senders = new Map();
        utility.requireArgument(this._logCallback, '_logCallback', 'function');
        utility.requireArgument(this._metricsCallback, '_metricsCallback', 'function');
        utility.requireArgument(this._commErrorCallback, '_commErrorCallback', 'function');
    }
    openComms(sender) {
        utility.requireArgument(sender, 'sender', 'object');
        if (!this._senders.has(sender)) {
            const messageChannel = new MessageChannel();
            const status = {
                state: CommState.Opening,
                port: messageChannel.port1
            };
            this._senders.set(sender, status);
            status.port.onmessage = this._messagePortEventHandler.bind(this);
            status.port.onmessageerror = this._messagePortErrorHandler.bind(this);
            sender.postMessage({
                from: MESSAGE_FROM_RECEIVER,
                type: MESSAGE_TYPE_HANDSHAKE
            }, '*', [messageChannel.port2]);
        }
    }
    closeComms(sender) {
        const status = this._senders.get(sender);
        if (status) {
            status.port.onmessage = undefined;
            status.port.onmessageerror = undefined;
            this._senders.delete(sender);
        }
    }
    _messagePortEventHandler(e) {
        if (e.data.type === MESSAGE_TYPE_LOG) {
            this._logCallback(e.data.data);
        }
        else if (e.data.type === MESSAGE_TYPE_METRICS) {
            this._metricsCallback(e.data.data);
        }
    }
    _messagePortErrorHandler() {
        this._commErrorCallback();
    }
}

const MESSAGE_TYPE_HANDSHAKE = 'handshake';
const MESSAGE_TYPE_LOG = 'log';
const MESSAGE_TYPE_METRICS = 'metrics';
class SenderConnector {
    constructor(_self, _allowedOrigins) {
        this._self = _self;
        this._allowedOrigins = _allowedOrigins;
        this._messageEventHandlerFunc = this._messageEventHandler.bind(this);
        this._handshakeComplete = false;
        this._logBuffer = [];
        this._metricsBuffer = [];
        utility.requireArgument(this._self, '_self', 'object');
        utility.requireArgumentIfDefined(_allowedOrigins, 'allowedOrigins', Array);
        this._self.addEventListener('message', this._messageEventHandlerFunc);
    }
    _messageEventHandler(e) {
        if (e.data.from === MESSAGE_FROM_RECEIVER &&
            e.data.type === MESSAGE_TYPE_HANDSHAKE &&
            e.ports[0] instanceof MessagePort &&
            utility.isAllowedOrigin(e.origin, this._allowedOrigins)) {
            this._handshakeComplete = true;
            this._self.removeEventListener('message', this._messageEventHandlerFunc);
            this._otherPort = e.ports[0];
            this._emptyBuffers();
        }
    }
    sendLog(log) {
        if (!this._handshakeComplete) {
            this._logBuffer.push(log);
        }
        else {
            this._otherPort.postMessage({
                type: MESSAGE_TYPE_LOG,
                data: log
            });
        }
    }
    sendMetrics(metrics) {
        if (!this._handshakeComplete) {
            this._metricsBuffer.push(metrics);
        }
        else {
            this._otherPort.postMessage({
                type: MESSAGE_TYPE_METRICS,
                data: metrics
            });
        }
    }
    _emptyBuffers() {
        this._logBuffer.forEach((log) => this.sendLog(log));
        this._metricsBuffer.forEach((metrics) => this.sendMetrics(metrics));
        this._logBuffer = undefined;
        this._metricsBuffer = undefined;
    }
}

class MetricsStore {
    constructor() {
        this._upCounters = [];
        this._valueRecorders = [];
        this._bucketHistograms = [];
    }
    add(senderMetrics) {
        var _a, _b, _c;
        if ((_a = senderMetrics.upCounters) === null || _a === void 0 ? void 0 : _a.length) {
            this._upCounters.push(...senderMetrics.upCounters.map((it) => new UpCounterImpl(it.name, it.ownerName, it.ownerAppName, metricsUtility.getMetricsTags(it.tags), it.createdTimestamp, it.lastUpdatedTimestamp, it.value)));
        }
        if ((_b = senderMetrics.valueRecorders) === null || _b === void 0 ? void 0 : _b.length) {
            this._valueRecorders.push(...senderMetrics.valueRecorders.map((it) => new ValueRecorderImpl(it.name, it.ownerName, it.ownerAppName, metricsUtility.getMetricsTags(it.tags), it.createdTimestamp, it.lastUpdatedTimestamp, it.values)));
        }
        if ((_c = senderMetrics.bucketHistograms) === null || _c === void 0 ? void 0 : _c.length) {
            this._bucketHistograms.push(...senderMetrics.bucketHistograms.map((it) => new BucketHistogramImpl(it.name, it.ownerName, it.ownerAppName, metricsUtility.getMetricsTags(it.tags), it.buckets, it.createdTimestamp, it.lastUpdatedTimestamp, it.values)));
        }
    }
    getUpCounters() {
        this._upCounters = this._upCounters.filter((i) => i.getLastUpdatedOn() !== undefined);
        return this._upCounters;
    }
    getValueRecorders() {
        this._valueRecorders = this._valueRecorders.filter((i) => i.getLastUpdatedOn() !== undefined);
        return this._valueRecorders;
    }
    getBucketHistograms() {
        this._bucketHistograms = this._bucketHistograms.filter((i) => i.getLastUpdatedOn() !== undefined);
        return this._bucketHistograms;
    }
}

const DEFAULT_POLL_INTERVAL = 1000;
class SenderCollector {
    constructor(_connector, _pollInterval) {
        this._connector = _connector;
        this._pollInterval = DEFAULT_POLL_INTERVAL;
        utility.requireArgument(_connector, '_connector', 'object');
        if (utility.requireArgumentIfDefined(_pollInterval, '_pollInterval', 'number') &&
            _pollInterval > 0) {
            this._pollInterval = _pollInterval;
        }
    }
    collect(schema, data, logMeta) {
        const msg = {
            schema,
            data,
            logMeta
        };
        this._connector.sendLog(msg);
    }
    receiveMetricsExtractors(extractors) {
        this._metricsExtractors = extractors;
        this._collectAndSendMetrics();
        setInterval(this._collectAndSendMetrics.bind(this), this._pollInterval);
    }
    _collectAndSendMetrics() {
        const metrics = {
            upCounters: metricsUtility.getUpCounters(this._metricsExtractors.getAllUpCounters()),
            valueRecorders: metricsUtility.getValueRecorders(this._metricsExtractors.getAllValueRecorders()),
            bucketHistograms: metricsUtility.getBucketHistograms(this._metricsExtractors.getAllBucketHistograms())
        };
        if (metrics.upCounters.length ||
            metrics.valueRecorders.length ||
            metrics.bucketHistograms.length) {
            this._connector.sendMetrics(metrics);
        }
    }
}

const maxInstrumentationLength = 80;
const defaultRootIdLength = 32;
const truncatedText = '_CUT';
const maxInstrumentationLengthBeforeTruncated = maxInstrumentationLength - truncatedText.length;
function noOpFunc() { }
class NextgenImpl {
    get preferredRootIdLength() {
        return this._preferredRootIdLength;
    }
    get pagePayloadProvider() {
        return this._pagePayloadProvider;
    }
    set pagePayloadProvider(provider) {
        this._pagePayloadProvider = provider;
    }
    get appPayloadProvider() {
        return this._appPayloadProvider;
    }
    set appPayloadProvider(provider) {
        this._appPayloadProvider = provider;
    }
    constructor(_idleDetector) {
        this._idleDetector = _idleDetector;
        this._logCollectors = new Set();
        this._instruments = new Map();
        this._seqBySchema = new Map();
        this._sequence = 0;
        this._forceDisabledLogCollectors = new Set();
        this._logCollectorFailures = new Map();
        this._isBufferingEnabled = false;
        this._buffer = [];
        this._logCollectionListeners = new Set();
        this._opMode = 'default';
        this._isSender = false;
        this._isReceiver = false;
        this._decimalPoints = 2;
    }
    registerApp(name, options) {
        var _a, _b;
        utility.requireArgument(name, 'name', 'string');
        if (this._appInstr) {
            throw new Error('An app has already been registered with instrumentation.');
        }
        const instr = this._instruments.get(name);
        if (instr) {
            throw new Error(`The instrumentation name ${name} is already taken`);
        }
        co11y.setOwnerAppName(name);
        this._initOpMode(options === null || options === void 0 ? void 0 : options.operationMode);
        this._isSender = this._opMode === 'sender';
        this._isReceiver = this._opMode === 'receiver';
        if ((options === null || options === void 0 ? void 0 : options.decimalPoints) !== undefined) {
            this._decimalPoints = options.decimalPoints;
        }
        this._preferredRootIdLength = (_a = options === null || options === void 0 ? void 0 : options.preferredRootIdLength) !== null && _a !== void 0 ? _a : defaultRootIdLength;
        this._clientSessionId = ((_b = options === null || options === void 0 ? void 0 : options.clientSessionId) === null || _b === void 0 ? void 0 : _b.toString()) || utility.generateUniqueId();
        this._appInstr = new AppInstrumentationImpl(this, name, options === null || options === void 0 ? void 0 : options.allowMultipleRootActivities);
        this._instruments.set(name, this._appInstr);
        if (this._isSender) {
            const senderCollector = new SenderCollector(new SenderConnector(window, options === null || options === void 0 ? void 0 : options.allowedReceiverOrigins), options === null || options === void 0 ? void 0 : options.senderMetricsPollingInterval);
            this.registerLogCollector(senderCollector);
            this.registerMetricsCollector(senderCollector);
        }
        else if (this._isReceiver) {
            this._metricsStore = new MetricsStore();
            this._receiverConnector = new ReceiverConnector((msg) => {
                msg.logMeta.receiverClientSessionId = this._clientSessionId;
                msg.logMeta.receiverRootId = this._appInstr.getSingleRootActivityId();
                this._multiplex(msg.schema, msg.data, msg.logMeta);
            }, (msg) => {
                this._metricsStore.add(msg);
            }, () => {
                this._appInstr.incrementCounter('o11y-error-receiver', 1, true);
            });
        }
        this._isBufferingEnabled = !this._isSender && (options === null || options === void 0 ? void 0 : options.enableBuffering);
        const tracing = new Tracing(this.getInstrumentation('Network'), this._idleDetector);
        return {
            log: this._appInstr.log.bind(this._appInstr),
            error: this._appInstr.error.bind(this._appInstr),
            startActivity: this._appInstr.startActivity.bind(this._appInstr),
            domEvent: this._appInstr.domEvent.bind(this._appInstr),
            incrementCounter: this._appInstr.incrementCounter.bind(this._appInstr),
            trackValue: this._appInstr.trackValue.bind(this._appInstr),
            bucketValue: this._appInstr.bucketValue.bind(this._appInstr),
            networkInstrumentation: tracing.networkInstrumentation.bind(tracing),
            registerForLogPrompt: this._appInstr.registerForLogPrompt.bind(this._appInstr),
            activity: this._appInstr.activity.bind(this._appInstr),
            activityAsync: this._appInstr.activityAsync.bind(this._appInstr),
            startRootActivity: this._appInstr.startRootActivity.bind(this._appInstr),
            registerLogCollector: this._isSender ? noOpFunc : this.registerLogCollector.bind(this),
            registerMetricsCollector: this._isSender
                ? noOpFunc
                : this.registerMetricsCollector.bind(this),
            activateClickTracker: this.activateClickTracker.bind(this),
            deactivateClickTracker: this.deactivateClickTracker.bind(this),
            disableBuffering: this.disableBuffering.bind(this),
            promptLogCollection: this.promptLogCollection.bind(this),
            getClientSessionId: this.getClientSessionId.bind(this),
            getOperationMode: this.getOperationMode.bind(this),
            startReceiving: this._isReceiver
                ? this._receiverConnector.openComms.bind(this._receiverConnector)
                : noOpFunc,
            stopReceiving: this._isReceiver
                ? this._receiverConnector.closeComms.bind(this._receiverConnector)
                : noOpFunc
        };
    }
    getInstrumentation(name) {
        utility.requireArgument(name, 'name', 'string');
        if (name.length > maxInstrumentationLength) {
            name = name.substring(0, maxInstrumentationLengthBeforeTruncated) + truncatedText;
        }
        let instr = this._instruments.get(name);
        if (!instr) {
            instr = new InstrumentationImpl(this, name);
            this._instruments.set(name, instr);
        }
        else if (instr === this._appInstr) {
            throw new Error(`The instrumentation name ${name} is being used by the app.`);
        }
        return instr;
    }
    get appName() {
        var _a;
        return (_a = this._appInstr) === null || _a === void 0 ? void 0 : _a.name;
    }
    getRootActivityHistoryEntryByTime(atTime) {
        var _a;
        return (_a = this._appInstr) === null || _a === void 0 ? void 0 : _a.getRootActivityHistoryEntry(atTime);
    }
    addLog(loggerName, schema, data, timestamp, rootId) {
        var _a, _b, _c;
        payloadUtility.checkInputs(schema, data);
        this._sequence += 1;
        const isInternal = schemaUtil.isInternal(schema);
        const userSchema = isInternal && (data === null || data === void 0 ? void 0 : data.userPayload) ? data.userPayload.schema : schema;
        const schemaId = schemaUtil.getSchemaId(userSchema);
        let schemaSequence = this._seqBySchema.get(schemaId) || 0;
        schemaSequence += 1;
        this._seqBySchema.set(schemaId, schemaSequence);
        const logMeta = {
            timestamp,
            rootId,
            sequence: this._sequence,
            schemaSequence,
            loggerName,
            pagePayload: undefined,
            appPayload: undefined,
            loggerAppName: this.appName,
            connectionType: utility.getConnectionType(),
            clientSessionId: this._clientSessionId,
            age: utility.getAge(timestamp)
        };
        const payloadArgs = {
            schema,
            data,
            logMeta
        };
        logMeta.pagePayload = payloadUtility.getPayloadFromProvider(this.pagePayloadProvider, payloadArgs);
        logMeta.appPayload = payloadUtility.getPayloadFromProvider(this.appPayloadProvider, payloadArgs);
        if (!this._isSender) {
            data = utility.clone(data);
        }
        if (typeof this._decimalPoints === 'number') {
            utility.roundNumbersInObject(data, this._decimalPoints);
            if (isInternal) {
                utility.roundNumbersInObject((_a = data.userPayload) === null || _a === void 0 ? void 0 : _a.payload, this._decimalPoints);
            }
            utility.roundNumbersInObject((_b = logMeta.pagePayload) === null || _b === void 0 ? void 0 : _b.payload, this._decimalPoints);
            utility.roundNumbersInObject((_c = logMeta.appPayload) === null || _c === void 0 ? void 0 : _c.payload, this._decimalPoints);
        }
        if (this._isBufferingEnabled) {
            const bufferedLog = {
                schema,
                data,
                logMeta
            };
            this._buffer.push(bufferedLog);
        }
        this._multiplex(schema, data, logMeta);
        return this._sequence;
    }
    _multiplex(schema, data, logMeta) {
        const eligibleCollectors = Array.from(this._logCollectors).filter((collector) => {
            var _a;
            return !this._forceDisabledLogCollectors.has(collector) &&
                !((_a = collector.getIsCollectDisabled) === null || _a === void 0 ? void 0 : _a.call(collector));
        });
        if (eligibleCollectors.length > 0) {
            for (const collector of eligibleCollectors) {
                let failures = this._logCollectorFailures.get(collector) || 0;
                try {
                    collector.collect(schema, data, logMeta);
                    if (failures > 0) {
                        this._logCollectorFailures.set(collector, failures - 1);
                    }
                }
                catch (err) {
                    failures += 1;
                    if (failures >= NextgenImpl._collectorFailureLimit) {
                        this._forceDisabledLogCollectors.add(collector);
                        if (this._appInstr && (typeof err === 'string' || err instanceof Error)) {
                            this._appInstr.error(err);
                        }
                    }
                    else {
                        this._logCollectorFailures.set(collector, failures);
                    }
                }
            }
        }
    }
    getBuffer() {
        return this._buffer;
    }
    disableBuffering() {
        this._isBufferingEnabled = false;
        this._buffer = [];
    }
    getClickTracker() {
        return this._autoClickTracker;
    }
    getDefaultInstrumentationContext() {
        var _a, _b;
        return {
            rootId: (_a = this._appInstr) === null || _a === void 0 ? void 0 : _a.getSingleRootActivityId(),
            isRootActivitySampled: (_b = this._appInstr) === null || _b === void 0 ? void 0 : _b.isSingleRootActivitySampled()
        };
    }
    activateClickTracker() {
        if (typeof document !== 'undefined') {
            if (!this._autoClickTracker) {
                this._autoClickTracker = new AutomaticClickTracker(this._appInstr, document);
            }
            this._autoClickTracker.activate();
        }
    }
    deactivateClickTracker() {
        if (this._autoClickTracker) {
            this._autoClickTracker.deactivate();
            this._autoClickTracker = undefined;
        }
    }
    registerLogCollector(collector, options) {
        utility.requireArgument(collector, 'collector');
        if (this._logCollectors.has(collector)) {
            return;
        }
        this._logCollectors.add(collector);
        this._logCollectorFailures.set(collector, 0);
        if ((!collector.getIsCollectDisabled || !collector.getIsCollectDisabled()) &&
            (options === null || options === void 0 ? void 0 : options.retroactive)) {
            for (const log of this._buffer) {
                collector.collect(log.schema, log.data, log.logMeta);
            }
        }
    }
    registerMetricsCollector(collector) {
        utility.requireArgument(collector, 'collector');
        if (this._metricsCollector) {
            throw new Error('A metrics Collector is already registered.');
        }
        this._metricsCollector = collector;
        this._metricsCollector.receiveMetricsExtractors({
            getAllUpCounters: this._getAllUpCounters.bind(this),
            getAllValueRecorders: this._getAllValueRecorders.bind(this),
            getAllBucketHistograms: this._getAllBucketHistograms.bind(this)
        });
    }
    _getAllUpCounters() {
        var _a;
        return (((_a = this._metricsStore) === null || _a === void 0 ? void 0 : _a.getUpCounters()) || [])
            .concat(Array.from(this._instruments.values())
            .map((instr) => instr.getUpCounters())
            .flat())
            .concat(co11y.getUpCounters());
    }
    _getAllValueRecorders() {
        var _a;
        return (((_a = this._metricsStore) === null || _a === void 0 ? void 0 : _a.getValueRecorders()) || [])
            .concat(Array.from(this._instruments.values())
            .map((instr) => instr.getValueRecorders())
            .flat())
            .concat(co11y.getValueRecorders());
    }
    _getAllBucketHistograms() {
        var _a;
        return (((_a = this._metricsStore) === null || _a === void 0 ? void 0 : _a.getBucketHistograms()) || [])
            .concat(Array.from(this._instruments.values())
            .map((instr) => instr.getBucketHistograms())
            .flat())
            .concat(co11y.getBucketHistograms());
    }
    registerForLogPrompt(listener) {
        this._logCollectionListeners.add(listener);
    }
    promptLogCollection(reason) {
        for (const listener of this._logCollectionListeners.keys()) {
            try {
                listener(reason);
            }
            catch (err) {
                if (!utility.isProduction) {
                    throw err;
                }
            }
        }
    }
    getClientSessionId() {
        return this._clientSessionId;
    }
    _initOpMode(opMode) {
        if (typeof opMode === 'function') {
            opMode = opMode();
        }
        if (opMode === undefined || typeof window !== 'object') {
            opMode = 'default';
        }
        if (['default', 'receiver', 'sender'].indexOf(opMode) >= 0) {
            this._opMode = opMode;
        }
        else {
            throw new Error(`Invalid operation mode: ${opMode}`);
        }
    }
    getOperationMode() {
        return this._opMode;
    }
}
NextgenImpl._collectorFailureLimit = 5;

class Index {
    get _lazyNextGen() {
        if (!this._nextgen) {
            this._nextgen = new NextgenImpl(this._idleDetector);
        }
        return this._nextgen;
    }
    constructor(_idleDetector) {
        this._idleDetector = _idleDetector;
        utility.requireArgument(_idleDetector, '_idleDetector');
    }
    registerInstrumentedApp(name, options) {
        const retVal = this._lazyNextGen.registerApp(name, options);
        if (options) {
            utility.markProduction(options.isProduction);
            this._nextgen.appPayloadProvider = options.appPayloadProvider;
            this._nextgen.pagePayloadProvider = options.pagePayloadProvider;
        }
        return retVal;
    }
    getInstrumentation(name) {
        return this._lazyNextGen.getInstrumentation(name);
    }
}
const time = utility.time.bind(utility);

const lightningLoggerSchemaId = 'sfcore.customCmp.CustomComponentLog';
const bgColorMap = {
    Error: 'Crimson',
    Activity: 'CadetBlue',
    InstrumentedEvent: 'DarkOliveGreen',
    O11ySample: 'BlueViolet'
};
const colorMap = {
    Error: 'white',
    Activity: 'white',
    InstrumentedEvent: 'white',
    O11ySample: 'white'
};
const defaultColor = 'black';
const defaultBgColor = 'Gainsboro';
class ConsoleCollector {
    constructor(environment) {
        this._simpleFilters = new Set();
        this._regexFilters = [];
        if (environment) {
            this._log('ConsoleCollector', environment);
        }
    }
    collect(schema, data, logMeta) {
        const id = schemaUtil.getSchemaId(schema);
        if (!this._shouldLog(id)) {
            return;
        }
        if (id === lightningLoggerSchemaId) {
            this._logCustom(data);
            return;
        }
        let label, color, bgColor;
        if (schemaUtil.isInternal(schema)) {
            label = schema.name;
            color = colorMap[schema.name] || defaultColor;
            bgColor = bgColorMap[schema.name] || defaultBgColor;
        }
        else {
            label = id;
        }
        this._log(label, data, logMeta, color, bgColor);
    }
    _shouldLog(schemaId) {
        if (this._simpleFilters.size == 0 && this._regexFilters.length == 0) {
            return true;
        }
        return (this._simpleFilters.has(schemaId) || this._regexFilters.some((r) => r.test(schemaId)));
    }
    addFilter(filter) {
        if (filter instanceof RegExp) {
            this._regexFilters.push(filter);
        }
        else {
            this._simpleFilters.add(filter);
        }
    }
    removeFilter(filter) {
        if (filter instanceof RegExp) {
            const index = this._regexFilters.findIndex((r) => r.source === filter.source);
            if (index >= 0) {
                this._regexFilters.splice(index, 1);
            }
        }
        else {
            this._simpleFilters.delete(filter);
        }
    }
    clearFilters() {
        this._simpleFilters.clear();
        this._regexFilters.splice(0, this._regexFilters.length);
    }
    getFilters() {
        const filters = Array.from(this._simpleFilters);
        return filters.concat(this._regexFilters).sort();
    }
    _log(label, first, second, color = defaultColor, bgColor = defaultBgColor) {
        const css = `color:${color};background-color:${bgColor}`;
        console.log(`%cO11Y%c ${label}`, 'color:white;background-color:#FF6600;font-weight:bold', css, first || '', second || '');
    }
    _logCustom(data) {
        console.log('%clightning/logger', 'color:white;background-color:#00a1e0;font-weight:bold', data || '');
    }
}

const version = '250.14.0';

const idleDetector = new IdleDetectorImpl({
    logThreshold: 300,
    reportListener: (report) => {
        idleDetectorInstr === null || idleDetectorInstr === void 0 ? void 0 : idleDetectorInstr.log(idleDetectorReportSchema, report);
    },
    errorListener: (e, text) => {
        idleDetectorInstr === null || idleDetectorInstr === void 0 ? void 0 : idleDetectorInstr.error(e, text);
    }
});
const index = new Index(idleDetector);
const registerInstrumentedApp = index.registerInstrumentedApp.bind(index);
const getInstrumentation = index.getInstrumentation.bind(index);
const idleDetectorInstr = getInstrumentation('IdleDetector');

export { ConsoleCollector, version as _version, getInstrumentation, idleDetector, registerInstrumentedApp, time };
//# sourceMappingURL=client.js.map
