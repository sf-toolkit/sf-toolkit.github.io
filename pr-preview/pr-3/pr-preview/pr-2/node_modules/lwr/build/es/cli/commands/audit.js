import { transformSync } from '@lwc/compiler';
import { resolveModule } from '@lwc/module-resolver';
import { loadConfig } from '@lwrjs/config';
import { explodeSpecifier, getImportMetadata } from '@lwrjs/shared-utils';
import { Command } from 'commander';
import chalk from 'chalk';
import path from 'path';
import fs from 'fs';
import treeify from 'object-treeify';
import { parseStringPromise } from 'xml2js';
const CAPABILITY_SSR_ONLY = 'lightning__ServerRenderable'; // SSR-only
const CAPABILITY_SSR_HYDRATION = 'lightning__ServerRenderableWithHydration'; // SSR with hydration
const CAPABILITY_UNKNOWN = 'Unknown'; // unresolvable modules
const CAPABILITY_PRIVATE = 'Private'; // unexposed platform modules (eg: "lwr/routerUtils", "lightning/primitiveIcon")
const PLATFORM_NS = ['lwr', 'webruntime', 'lightning'];
const LWC_REGEX = /^[\w-]+\/[\w-]+$/; // LWC component specifier format
const LWC_TRANSFORM_CONFIG = {
    // pass to the LWC compiler
    experimentalDynamicComponent: { strictSpecifier: false },
    enableDynamicComponents: true,
    enableScopedSlots: true,
};
const SFDX_CONFIG_PATH = 'sfdx-project.json';
const CACHE = new Map();
export function createAuditCommand() {
    return new Command('audit')
        .description('Audit the SSR capabilities of components')
        .requiredOption('--components <component...>', '[string] space-separated list of component names to analyze (eg "header footer nav")')
        .option('--namespace <string>', '[string] namespace of the components', 'c')
        .option('--depth <number>', '[number] number of levels to analyze', '1')
        .option('--verbose', '[boolean] show tree of all analyzed components', false)
        .action(async (options, cmd) => {
        // Read options and config
        CACHE.clear(); // use a fresh cache for each audit
        const opts = cmd.optsWithGlobals();
        const { components, config, depth: depthStr, namespace: ns, rootDir, verbose } = opts;
        const lwcConfig = getLwcConfig(rootDir, config);
        // Check that the depth is at least 1
        let depth = parseInt(depthStr);
        if (isNaN(depth) || depth < 1) {
            console.log(chalk.bgYellow('WARN'), `Depth cannot be ${depthStr}, defaulting to 1`);
            depth = 1;
        }
        // Analyze the components and print the results
        const cmpList = components.map((c) => `${ns}/${c}`).join(', ');
        console.log(`âœ¨ Auditing SSR capabilities for ${chalk.bgGray(cmpList)}...`);
        let greatSuccess = true;
        for (const c of components) {
            const info = await analyzeComponentCapabilities(`${ns}/${c}`, rootDir, lwcConfig, depth);
            if (info) {
                const success = print(info, verbose);
                greatSuccess = success && greatSuccess;
            }
            else {
                greatSuccess = false;
                console.log(chalk.bgRed('FAIL'), chalk.bgGray(`${ns}/${c}`), 'cannot be found');
            }
        }
        if (!greatSuccess)
            process.exit(1);
    });
}
/** COMPONENT AUDIT HELPERS **/
/**
 * Analyzes a component tree's SSR capabilities to a given depth and prints out a compatibility audit
 * @param specifier Specifier for the given component
 * @param rootDir Path for the project root directory
 * @param modules LWC modules configuration (ie: alias, dir and npm module records)
 * @param depth The number of levels to check in the component tree
 * @returns Specifier, SSR capability and children for a component, or undefined if the component cannot be resolved
 */
async function analyzeComponentCapabilities(specifier, rootDir, modules, depth) {
    if (CACHE.has(specifier))
        return CACHE.get(specifier);
    const cmpDir = await getComponentDir(specifier, rootDir, modules);
    const info = cmpDir
        ? {
            specifier: specifier,
            ssrCapability: await parseSsrCapability(specifier, cmpDir),
            children: await analyzeChildren(specifier, cmpDir, rootDir, modules, depth),
        }
        : undefined;
    info && CACHE.set(specifier, info);
    return info;
}
/**
 * Resolve a component to find its directory path
 * @param specifier Specifier for the given component
 * @param rootDir Path for the project root directory
 * @param modules LWC modules configuration (ie: alias, dir and npm module records)
 * @returns Path to the directory of the component, or undefined if the component cannot be resolved
 */
async function getComponentDir(specifier, rootDir, modules) {
    try {
        // SFDX projects do not have namespace folders, but they have a top-level "lwc" dir
        const s = isSFDX(rootDir) ? specifier.replace(/^c\//, 'lwc/') : specifier;
        const { entry } = resolveModule(s, rootDir, { modules, rootDir });
        return path.dirname(entry);
    }
    catch (e) {
        if (e.code === 'NO_LWC_MODULE_FOUND') {
            // The component is not on the local file system
            return undefined;
        }
        else {
            throw e;
        }
    }
}
/**
 * Parse the SSR capability from a component's js-meta file
 * @param specifier Specifier for the given component
 * @param cmpDir Path to the component directory
 * @returns An SSR capability or undefined (ie: CSR-only)
 */
async function parseSsrCapability(specifier, cmpDir) {
    const xml = readFile(path.join(cmpDir, `${explodeSpecifier(specifier).name}.js-meta.xml`));
    if (!xml) {
        // some components may not have a js-meta file
        console.log(chalk.bgYellow('WARN'), chalk.bgGray(specifier), 'does not have a js-meta.xml file');
        return undefined;
    }
    const metadata = await parseStringPromise(xml);
    const capabilities = metadata.LightningComponentBundle?.capabilities;
    const capability = Array.isArray(capabilities) ? capabilities[0].capability : undefined;
    if (Array.isArray(capability)) {
        return capability.includes(CAPABILITY_SSR_ONLY)
            ? CAPABILITY_SSR_ONLY
            : capability.includes(CAPABILITY_SSR_HYDRATION)
                ? CAPABILITY_SSR_HYDRATION
                : undefined;
    }
    else if (typeof capability === 'string') {
        return capability.startsWith(CAPABILITY_SSR_ONLY) ? capability : undefined;
    }
    return undefined;
}
/**
 * Recursively get the SSR capabilities for the components in a tree to a given depth
 * @param specifier Specifier for the given component
 * @param cmpDir Path to the component directory
 * @param rootDir Path for the project root directory
 * @param modules LWC modules configuration (ie: alias, dir and npm module records)
 * @param maxDepth The number of levels to check in the component tree
 * @param curDepth The depth currently being analyzed
 * @returns An array of component specifiers and SSR capabilities
 */
async function analyzeChildren(specifier, cmpDir, rootDir, modules, maxDepth = 1, curDepth = 0) {
    if (curDepth === maxDepth)
        return [];
    const htmlDeps = await parseHtmlDeps(specifier, cmpDir);
    const jsDeps = await parseJsDeps(specifier, cmpDir);
    const deps = [...htmlDeps, ...jsDeps];
    const children = [];
    for (const d of deps) {
        if (CACHE.has(d)) {
            children.push(CACHE.get(d));
            continue;
        }
        const dir = await getComponentDir(d, rootDir, modules);
        const { namespace = '' } = explodeSpecifier(d);
        const child = dir // dir is undefined if the component cannot be resolved
            ? {
                specifier: d,
                ssrCapability: await parseSsrCapability(d, dir),
                children: await analyzeChildren(d, dir, rootDir, modules, maxDepth, curDepth + 1),
            }
            : PLATFORM_NS.includes(namespace)
                ? { specifier: d, ssrCapability: CAPABILITY_PRIVATE, children: [] }
                : { specifier: d, ssrCapability: CAPABILITY_UNKNOWN, children: [] };
        CACHE.set(d, child);
        children.push(child);
    }
    return children;
}
/**
 * Parse the LWC component dependencies from a component's HTML
 * @param specifier Specifier for the given component
 * @param cmpDir Path to the component directory
 * @returns An array of component specifiers
 */
async function parseHtmlDeps(specifier, cmpDir) {
    const filename = `${explodeSpecifier(specifier).name}.html`;
    const htmlCode = readFile(path.join(cmpDir, filename));
    if (!htmlCode)
        return []; // some LWC modules do not have HTML
    const { namespace, name } = explodeSpecifier(specifier);
    const { code } = transformSync(htmlCode, filename, { ...LWC_TRANSFORM_CONFIG, namespace, name });
    const { imports = [] } = await getImportMetadata(code);
    return imports.map((i) => i.moduleSpecifier).filter((d) => LWC_REGEX.test(d));
}
/**
 * Parse the LWC component dependencies from a component's JS
 * @param specifier Specifier for the given component
 * @param cmpDir Path to the component directory
 * @returns An array of component specifiers
 */
async function parseJsDeps(specifier, cmpDir) {
    let jsCode = readFile(path.join(cmpDir, `${explodeSpecifier(specifier).name}.js`));
    if (!jsCode) {
        // try looking for a ts file if a js file not found
        jsCode = readFile(path.join(cmpDir, `${explodeSpecifier(specifier).name}.ts`));
    }
    if (!jsCode)
        return [];
    const { imports = [] } = await getImportMetadata(jsCode);
    return imports.map((i) => i.moduleSpecifier).filter((d) => LWC_REGEX.test(d));
}
/** FILE SYSTEM HELPERS **/
/**
 * Read in the LWC modules configuration for the project
 * @param rootDir Path for the project root directory
 * @param lwrConfigPath Path to the lwr.config.json file
 * @returns LWC modules configuration (ie: alias, dir and npm module records)
 */
function getLwcConfig(rootDir, lwrFile) {
    // LWR project: lwr.config.json
    const absLwrConfigPath = path.isAbsolute(lwrFile) ? lwrFile : path.join(rootDir, lwrFile);
    if (fs.existsSync(absLwrConfigPath)) {
        const { appConfig } = loadConfig({ rootDir, lwrConfigFile: lwrFile });
        return appConfig.lwc.modules;
    }
    // LWC project: lwc.config.json
    const lwcConfigStr = readFile(path.join(rootDir, 'lwc.config.json'));
    if (lwcConfigStr) {
        const lwcConfig = JSON.parse(lwcConfigStr).lwc?.modules;
        if (lwcConfig)
            return lwcConfig;
    }
    // SFDX project: sfdx-project.json
    const sfdxConfigStr = readFile(path.join(rootDir, SFDX_CONFIG_PATH));
    const modules = [];
    if (sfdxConfigStr) {
        const sfdxConfig = JSON.parse(sfdxConfigStr);
        const pkgDirs = sfdxConfig.packageDirectories || [];
        // configure LWC to resolve modules from each package directory
        pkgDirs.forEach((d) => modules.push({ dir: path.join(d.path, 'main/default') }));
    }
    // LWC project: package.json
    // SFDX projects can have LWC config in a package.json
    const pkgConfigStr = readFile(path.join(rootDir, 'package.json'));
    if (pkgConfigStr) {
        const pkgConfig = JSON.parse(pkgConfigStr).lwc?.modules;
        if (pkgConfig)
            modules.push(...pkgConfig);
    }
    if (!modules.length) {
        // project has no config!
        console.log(chalk.bgRed('FAIL'), 'LWC config not found in', chalk.bgGray(rootDir));
        process.exit(1);
    }
    return modules;
}
/**
 * Read a file if it exists
 * @param filePath File path
 * @returns File contents or undefined if the file is not found
 */
function readFile(filePath) {
    if (fs.existsSync(filePath)) {
        return fs.readFileSync(filePath, 'utf8');
    }
}
/**
 * Determine if this is an SFDX project
 * @param rootDir Path for the project root directory
 * @returns True if this is an SFDX project
 */
function isSFDX(rootDir) {
    return fs.existsSync(path.join(rootDir, SFDX_CONFIG_PATH));
}
/** PRINTING HELPERS **/
const SUCCESS_MSG = 'contains no capability incompatibilities!';
const WARN_MSG = 'depends on one or more components which are not available locally and must be analyzed manually:';
const SSR_ERROR_MSG = 'has the ServerRenderable capability so it cannot depend on components with no SSR capability or the ServerRenderableWithHydration capability:';
const HYDRATE_ERROR_MSG = 'has the ServerRenderableWithHydration capability so it cannot depend on components with no SSR capability:';
const CSR_ONLY = 'No SSR capability';
const LIST_SEP = '\n    - ';
/**
 * Given a root component, print out whether or not SSR capability conflicts exist in its tree
 * @param info Specifier, SSR capability and children for a component
 * @param verbose True if the component tree should be printed out
 * @returns True if there are no incompatibilities
 */
function print(info, verbose = false) {
    let success = true;
    const childCaps = { hydrate: new Set(), csr: new Set(), unknown: new Set() };
    groupCapabilitiesByType(childCaps, info);
    if (verbose) {
        const tree = buildTree([info], info.ssrCapability, true);
        tree && console.log('\n', treeify(tree), '\n');
    }
    if (info.ssrCapability === CAPABILITY_SSR_HYDRATION && childCaps.csr.size) {
        // FAIL: root component is SSRed with hydration, but has CSR-only children
        success = false;
        console.log(chalk.bgRed('FAIL'), chalk.bgGray(info.specifier), HYDRATE_ERROR_MSG, LIST_SEP + [...childCaps.csr].join(LIST_SEP));
    }
    else if (info.ssrCapability === CAPABILITY_SSR_ONLY && (childCaps.csr.size || childCaps.hydrate.size)) {
        // FAIL: root component is SSR-only, but has CSR-only or hydrated children
        success = false;
        console.log(chalk.bgRed('FAIL'), chalk.bgGray(info.specifier), SSR_ERROR_MSG, LIST_SEP + [...childCaps.csr, ...childCaps.hydrate].join(LIST_SEP));
    }
    else {
        // PASS: root component is CSR-only, or there are no conflicts
        console.log(chalk.bgGreen('PASS'), chalk.bgGray(info.specifier), SUCCESS_MSG);
    }
    if (childCaps.unknown.size) {
        // WARN: there are components in the tree with unknown SSR capabilities
        console.log(chalk.bgYellow('WARN'), chalk.bgGray(info.specifier), WARN_MSG, LIST_SEP + [...childCaps.unknown].join(LIST_SEP));
    }
    return success;
}
/**
 * Organize all the capabilities in a component tree by type
 * @param all Arrays of component specifiers by SSR capability type: hydrate, CSR-only and unknown
 * @param info Specifier, SSR capability and children for a component
 * @returns Arrays of component specifiers by SSR capability type
 */
function groupCapabilitiesByType(all, info) {
    for (const c of info.children) {
        if (!c.ssrCapability) {
            all.csr.add(c.specifier);
        }
        else if (c.ssrCapability === CAPABILITY_SSR_HYDRATION) {
            all.hydrate.add(c.specifier);
        }
        else if (c.ssrCapability === CAPABILITY_UNKNOWN) {
            all.unknown.add(c.specifier);
        }
        groupCapabilitiesByType(all, c);
    }
    return all;
}
/**
 * Recursively build a tree object which shows the status, specifier and SSR capability of each component
 * @param info Specifier, SSR capability and children for a component
 * @param rootCap Capability of the root component being analyzed
 * @param isRoot True if the root is being processed
 * @returns A tree object which can be printed in verbose mode
 */
function buildTree(info, rootCap, isRoot = false) {
    if (!info.length)
        return null;
    const tree = {};
    for (const i of info) {
        const cap = i.ssrCapability;
        if (cap === CAPABILITY_PRIVATE)
            continue; // exclude private platform deps
        const status = isRoot
            ? ''
            : cap === CAPABILITY_UNKNOWN
                ? chalk.bgYellow('WARN')
                : !rootCap ||
                    (rootCap === CAPABILITY_SSR_ONLY && cap === CAPABILITY_SSR_ONLY) ||
                    (rootCap === CAPABILITY_SSR_HYDRATION && cap)
                    ? chalk.bgGreen('PASS')
                    : chalk.bgRed('FAIL');
        tree[`${status} ${chalk.bgGray(i.specifier)} ${cap || CSR_ONLY}`] = buildTree(i.children, rootCap);
    }
    return tree;
}
//# sourceMappingURL=audit.js.map