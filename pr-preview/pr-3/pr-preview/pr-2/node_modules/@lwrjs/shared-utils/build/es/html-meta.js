import { getPropFromAttrName, kebabCaseToModuleSpecifier } from './identity.js';
import SAXParser from 'parse5-sax-parser';
import { Readable } from 'stream';
function parseAssetLocation(htmlSource, tagName, attrLocation) {
    const { startOffset, endOffset } = attrLocation;
    const srcAttr = htmlSource.substring(startOffset, endOffset);
    // Split src="myURL"
    const split = srcAttr.indexOf('=');
    const keyAttr = srcAttr.substr(0, split);
    // Also remove the "s to just get myURL
    const url = srcAttr.slice(split + 2, -1);
    return {
        url,
        tagName,
        relative: isRelative(url),
        location: {
            startOffset: startOffset + keyAttr.length + 2 /* =" */,
            endOffset: endOffset - 1,
        },
    };
}
// Detect if this is a relative URL
export function isRelative(url) {
    return !url?.match(isNotRelativeRegex);
}
const isNotRelativeRegex = /^(http(s)?:\/\/|\/)/i;
// Detect if this is just a self referential URL
export function isSelfUrl(url) {
    return !url || !!url.match(isSelfUrlRegex);
}
const isSelfUrlRegex = /^\s*(data:|#)/i;
function hasHydrationDirective(attrs = {}) {
    return Object.keys(attrs).some((attr) => attr === HYDRATE_DIRECTIVE);
}
/**
 * Pull the custom elements and img tags out of an HTML string, to use as metadata
 * @param htmlSource - An HTML string to parse
 */
export async function extractMetadataFromHtml(htmlSource, viewMetadata, appConfig) {
    const { customElements, assetReferences } = viewMetadata;
    const { bundleConfig: { external = {} }, } = appConfig;
    const externals = Object.keys(external);
    return new Promise((resolve, reject) => {
        const openElements = new Set();
        const parser = new SAXParser({ sourceCodeLocationInfo: true }); // TODO: Would we need this in the future?
        const ceRefStack = [];
        let nestedIslands = false;
        parser.on('startTag', ({ tagName, attrs, // attributes are passed into SSR
        sourceCodeLocation, }) => {
            // custom elements
            if (tagName.includes('-') &&
                !openElements.has(tagName) &&
                !externals.includes(kebabCaseToModuleSpecifier(tagName))) {
                const { startOffset, endOffset } = sourceCodeLocation;
                // transform attributes [{ name: 'some-attr', value: 'the value' }] into properties { someAttr: 'the value' }
                // leave props as undefined if there are no attributes
                // set boolean attribute values to "true", or lwc will see them as falsy
                const props = attrs.length
                    ? attrs.reduce((obj, { name, value }) => {
                        obj[getPropFromAttrName(name)] = value === '' ? 'true' : value;
                        return obj;
                    }, {})
                    : undefined;
                const ceRef = { tagName, location: { startOffset, endOffset }, props };
                openElements.add(tagName);
                if (ceRefStack.length) {
                    // nested CE
                    const last = ceRefStack[ceRefStack.length - 1];
                    last.children = last.children ? [...last.children, ceRef] : [ceRef];
                    // nested CEs are collected if they have a hydration directive
                    if (hasHydrationDirective(props)) {
                        customElements.push(ceRef);
                        nestedIslands = true;
                    }
                }
                else {
                    // collect all top-level CEs
                    customElements.push(ceRef);
                }
                ceRefStack.push(ceRef);
            }
            // <img src="asset-url"/>
            // <script type="text/javascript" src="asset-url"></script>
            if ((tagName === 'img' || tagName === 'script') && sourceCodeLocation.attrs) {
                if (sourceCodeLocation.attrs.src) {
                    assetReferences.push(parseAssetLocation(htmlSource, tagName, sourceCodeLocation.attrs.src));
                }
                // if (sourceCodeLocation.attrs.srcset) {
                // TODO: WIP
                // }
            }
            // <link rel="stylesheet" href="asset-url">
            if (tagName === 'link' && sourceCodeLocation.attrs) {
                if (sourceCodeLocation.attrs.href) {
                    assetReferences.push(parseAssetLocation(htmlSource, tagName, sourceCodeLocation.attrs.href));
                }
            }
        });
        parser.on('endTag', ({ tagName, sourceCodeLocation, }) => {
            if (openElements.has(tagName)) {
                const ceRef = ceRefStack.pop();
                openElements.delete(tagName);
                if (!ceRef) {
                    throw new Error(`Error extracting metadata: Unmatched custom element close tag for ${tagName}`);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                ceRef.location.endOffset = sourceCodeLocation.endOffset;
            }
        });
        const inputStream = Readable.from(htmlSource);
        // If nested islands are found, ONLY collect custom elements with the hydration directive
        // Otherwise, just collect top-level custom elements (ie: root components) as usual
        inputStream.on('end', () => resolve({
            ...viewMetadata,
            customElements: customElements.filter((ce) => !nestedIslands || hasHydrationDirective(ce.props)),
            assetReferences,
        }));
        inputStream.on('error', (error) => reject(error));
        inputStream.pipe(parser);
    });
}
export const HYDRATE_DIRECTIVE = 'lwr:hydrate';
export const HYDRATE_LOAD_VALUE = 'load';
export const HYDRATE_CLIENT_VALUE = 'client-only';
const HYDRATION_VALUES = [HYDRATE_LOAD_VALUE, HYDRATE_CLIENT_VALUE];
export function getHydrateDirective(props = {}) {
    const rawValue = props[HYDRATE_DIRECTIVE];
    const value = rawValue === 'true' ? HYDRATE_LOAD_VALUE : rawValue; // valueless hyration directives => lwr:hydrate="load"
    if (HYDRATION_VALUES.includes(value))
        return value;
}
export function isHydrateOnLoad(props = {}) {
    return getHydrateDirective(props) === HYDRATE_LOAD_VALUE;
}
export function isCsrIsland(props = {}) {
    return getHydrateDirective(props) === HYDRATE_CLIENT_VALUE;
}
//# sourceMappingURL=html-meta.js.map