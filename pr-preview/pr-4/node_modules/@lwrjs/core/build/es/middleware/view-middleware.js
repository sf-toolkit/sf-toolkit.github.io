import { descriptions, logger } from '@lwrjs/diagnostics';
import { getClientRoutes } from '@lwrjs/router';
import { decodeViewPath, extractRequestParams, getClientBootstrapConfigurationRoutes, shortestTtl, } from '@lwrjs/shared-utils';
import { RequestHandlerSpan, getTracer } from '@lwrjs/instrumentation';
import { handleErrors } from './utils/error-handling.js';
import { LwrViewHandler } from '@lwrjs/view-registry';
function createViewMiddleware(route, errorRoutes, context, viewHandler) {
    const errorRoute = errorRoutes.find((route) => route.status === 500);
    const appConfig = context.appConfig;
    const { environment: environmentConfig } = appConfig;
    return async (req, res) => {
        if (!req.validateEnvironmentRequest(appConfig)) {
            res.status(400);
            res.send(descriptions.UNRESOLVABLE.INVALID_ENVIRONMENT(req.params.environment).message);
            return;
        }
        if (!req.validateJsonRequest()) {
            res.status(400);
            res.send(descriptions.UNRESOLVABLE.INVALID_JSON().message);
            return;
        }
        const { runtimeEnvironment, runtimeParams: defaultRuntimeParams } = req.getRuntimeContext(context.runtimeEnvironment);
        // set the default environment if an environment is configured in the app config
        if (!defaultRuntimeParams.environment && environmentConfig?.default) {
            defaultRuntimeParams.environment = environmentConfig.default;
        }
        const viewRequest = {
            url: req.originalUrl,
            params: req.params,
            query: req.query,
            requestPath: req.path,
        };
        // Augment runtime params with viewRequest info
        const runtimeParams = {
            ...defaultRuntimeParams,
            url: viewRequest.url,
            params: viewRequest.params,
            query: viewRequest.query,
        };
        const resolve = req.isJsonRequest() ? viewHandler.getViewJson : viewHandler.getViewContent;
        let viewResponse;
        let resolvedRoute;
        let traceId;
        try {
            viewResponse = await getTracer().trace({
                name: RequestHandlerSpan.GetView,
                attributes: {
                    view: route.id,
                    url: req.originalUrl,
                    host: runtimeParams.host,
                    basePath: runtimeParams.basePath,
                    locale: runtimeParams.locale,
                },
            }, (span) => {
                traceId = span.traceId;
                return resolve.call(viewHandler, viewRequest, route, runtimeEnvironment, runtimeParams);
            });
            resolvedRoute = route;
        }
        catch (err) {
            if (!errorRoute) {
                throw err;
            }
            // Log Unexpected Routing Errors
            logger.error(`[view-middleware] Route Error ${req.originalUrl}`);
            logger.error(err);
            viewResponse = await getTracer().trace({
                name: RequestHandlerSpan.GetView,
                attributes: {
                    view: errorRoute.id,
                },
            }, () => {
                return resolve.call(viewHandler, viewRequest, errorRoute, runtimeEnvironment, runtimeParams);
            });
            resolvedRoute = errorRoute;
        }
        if (req.isSiteGeneration()) {
            res.setSiteGenerationMetadata(viewResponse.metadata);
        }
        // view response will be html by default
        res.type('text/html');
        // the default content type can be overridden if specified by the view response
        if (viewResponse.headers) {
            res.set(viewResponse.headers);
        }
        // pick the shortest TTL between the view response and route object
        if (!res.hasHeader('cache-control')) {
            const cacheTtl = shortestTtl(viewResponse.cache?.ttl, resolvedRoute.cache?.ttl);
            if (cacheTtl) {
                res.setHeader('cache-control', `public, max-age=${cacheTtl}`);
            }
        }
        if (traceId?.length) {
            res.setHeader('x-trace-id', traceId);
        }
        const status = resolvedRoute.status || viewResponse.status || 200;
        res.status(status);
        res.send(viewResponse.body);
    };
}
function createConfigMiddleware(routes, context, viewHandler) {
    return async (req, res) => {
        const { runtimeEnvironment, runtimeParams: defaultRuntimeParams } = req.getRuntimeContext(context.runtimeEnvironment);
        const { appId, encodedViewPath } = req.params;
        // match the app id to a route
        const route = routes.find((route) => route.id === appId);
        if (!route) {
            res.status(404).send(descriptions.UNRESOLVABLE.APP_CONFIG(appId).message);
            return;
        }
        // decode the resolved view path and extract any params.
        const url = decodeViewPath(encodedViewPath);
        let requestPath = url;
        // Create an empty object to store the key-value pairs
        const query = {};
        if (url.indexOf('?') !== -1) {
            // Remove query string from the requestPath
            requestPath = url.substring(0, url.indexOf('?'));
            const searchParams = new URLSearchParams(url.substring(url.indexOf('?')));
            // Iterate over the entries of the URLSearchParams and populate the object
            for (const [key, value] of searchParams.entries()) {
                query[key] = value;
            }
        }
        const originalUrl = req.originalUrl;
        const routePath = route.path;
        const params = extractRequestParams(routePath, url, req.params);
        const viewRequest = {
            url,
            originalUrl,
            params,
            query,
            requestPath,
        };
        // Augment runtime params with viewRequest info
        const runtimeParams = {
            ...defaultRuntimeParams,
            url: viewRequest.url,
            params: viewRequest.params,
            query: viewRequest.query,
        };
        const viewResponse = await viewHandler.getViewConfiguration(viewRequest, route, runtimeEnvironment, runtimeParams);
        if (!viewResponse) {
            res.status(404).send(descriptions.UNRESOLVABLE.VIEW_CONFIG(url).message);
            return;
        }
        // Pick the shortest TTL between the view response and route object
        if (!res.hasHeader('cache-control')) {
            const cacheTtl = shortestTtl(viewResponse.cache?.ttl, route.cache?.ttl);
            if (cacheTtl) {
                res.setHeader('cache-control', `public, max-age=${cacheTtl}`);
            }
        }
        res.status(200);
        res.type('application/javascript');
        res.status(viewResponse.status || 200);
        res.send(viewResponse.body);
    };
}
function createNotFoundMiddleware(errorRoutes, context, viewHandler) {
    const notFoundRoute = errorRoutes.find((route) => route.status === 404);
    if (notFoundRoute) {
        return createViewMiddleware(notFoundRoute, errorRoutes, context, viewHandler);
    }
    return (req, res) => {
        res.status(404).send(descriptions.UNRESOLVABLE.VIEW(req.originalUrl).message);
    };
}
export function viewMiddleware(app, context) {
    const { appConfig, viewRegistry, moduleRegistry, routeHandlers } = context;
    const { i18n, routes, errorRoutes } = appConfig;
    const viewHandler = new LwrViewHandler({ viewRegistry, moduleRegistry, routeHandlers }, appConfig);
    // create and attach middleware for each route
    for (const route of routes) {
        const paths = [route.path];
        const subRoutes = route.subRoutes && getClientRoutes(route.subRoutes);
        if (subRoutes) {
            const prefix = route.path === '/' ? '' : route.path;
            subRoutes.routes.forEach((subRoute) => subRoute.uri !== route.path && paths.push(`${prefix}${subRoute.uri}`));
        }
        // Add localized routes
        if (i18n.uriPattern === 'path-prefix') {
            // Map all supported locale ids into an or patter /:locale(es|es-MX|fr|rd-CA).
            // Filter out the default locale.  It will be handled separately
            const supportedStr = i18n.locales
                .map((l) => l.id)
                .filter((id) => id !== i18n.defaultLocale)
                .join('|');
            if (supportedStr) {
                // Add a redirect handler for the default locale for each route  /en-US/home -> 301 /home
                const defaultLocalePaths = paths.map((routePath) => `/${i18n.defaultLocale}${routePath}`);
                paths.forEach((routePath) => {
                    const localizedPath = `/:locale(${supportedStr})${routePath}`;
                    paths.push(localizedPath);
                });
                addDefaultLocaleRedirects(i18n.defaultLocale, defaultLocalePaths, app);
            }
        }
        logger.debug({ label: `view-middleware`, message: `Add view paths ${paths}` });
        app.get(paths, handleErrors(createViewMiddleware(route, errorRoutes, context, viewHandler)));
    }
    // create and attach middleware for bootstrap configurations
    app.get(getClientBootstrapConfigurationRoutes(), handleErrors(createConfigMiddleware(routes, context, viewHandler)));
    // create and attach a greedy middleware to handle unsupported paths
    // NOTE: a greedy `all` is used over `use` due to the way middleware is mounted in the server abstraction
    app.get('/' + app.getRegexWildcard(), handleErrors(createNotFoundMiddleware(errorRoutes, context, viewHandler)));
}
/**
 * Adds a 301 redirect if attempting to route with default locale as the path prefix
 */
function addDefaultLocaleRedirects(defaultLocale, defaultLocalePaths, app) {
    logger.debug({ label: `view-middleware`, message: `Add default localized paths ${defaultLocalePaths}` });
    app.get(defaultLocalePaths, (req, res) => {
        // Get the original URL path and split it into segments
        let modifiedPath = req.originalUrl.replace(`/${defaultLocale}`, '');
        // Make sure there is a leading slash.  Redirect to '' causes an infinite loop.
        if (modifiedPath.indexOf('/') !== 0) {
            modifiedPath = `/${modifiedPath}`;
        }
        // Perform a 301 redirect to the modified URL
        res.setHeader('Location', modifiedPath);
        return res.sendStatus(301);
    });
}
//# sourceMappingURL=view-middleware.js.map