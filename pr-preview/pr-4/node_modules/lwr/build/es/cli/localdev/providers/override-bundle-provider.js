import StaticBundler from '@lwrjs/static/bundle-provider';
import fs from 'fs';
import path from 'path';
import { logger } from '@lwrjs/diagnostics';
const LWR_DEFINE_REGEX = /LWR\.define\(["']([^"']+)["']/g;
export default class StaticOverrideBundleProvider extends StaticBundler {
    constructor(options, context) {
        super(options, context);
        if (!context.siteMetadata) {
            throw new Error(`[${this.name}] Site metadata was not found`);
        }
        this.writeProdBundlesDir = options.writeProdBundlesDir;
        this.moduleRegistry = context.moduleRegistry;
        this.moduleBundler = context.moduleBundler;
        this.cacheDir = context.config.cacheDir;
        this.staticBundles = Object.keys(context.siteMetadata.getSiteBundles().bundles);
    }
    findIndex(index1, index2) {
        let startIndex;
        if (index1 !== -1) {
            if (index2 !== -1) {
                // Use the lowest value for start index
                startIndex = index1 > index2 ? index2 : index1;
            }
            else {
                startIndex = index1;
            }
        }
        else {
            startIndex = index2;
        }
        return startIndex;
    }
    async bundle(moduleId, runtimeEnvironment, runtimeParams) {
        const output = await super.bundle(moduleId, runtimeEnvironment, runtimeParams);
        // check if the requested module is a view bundle
        if (!output?.code || !moduleId.specifier.startsWith('@view')) {
            return output;
        }
        // scrape all "LWR.define"s
        const matches = Array.from(output.code.matchAll(LWR_DEFINE_REGEX), (match) => match[1]);
        const numOfLwrDefines = matches.length;
        if (!numOfLwrDefines) {
            return output;
        }
        // treat current directory and symlinks as local source
        const locals = (await Promise.all(matches.map(async (specifier) => {
            try {
                const entry = await this.moduleRegistry.getModuleEntry({ specifier });
                if (!entry.scope)
                    return undefined;
                const isSymLink = fs.lstatSync(entry.scope).isSymbolicLink();
                return entry?.scope === process.cwd() || isSymLink ? specifier : undefined;
            }
            catch (err) {
                return undefined;
            }
        }))).filter((s) => s !== undefined);
        // generate bundles using local source
        const codes = await Promise.all(locals.map(async (specifier) => {
            try {
                const local = await this.moduleBundler.getModuleBundle({ specifier }, runtimeEnvironment, runtimeParams, {
                    exclude: matches.concat(this.staticBundles),
                });
                return { specifier, code: '(function() { ' + local.code + '})();' };
            }
            catch (err) {
                logger.warn(`Failed to override "${specifier}"`);
                throw err;
            }
        }));
        // Hacky way of direct string replacing prod bundles with generated code
        if (this.writeProdBundlesDir) {
            for (let i = 0; i < codes.length; i++) {
                const obj = codes[i];
                this.packageProdSource(obj.specifier, obj.code, output);
            }
            // Verify the number of defines in the file match what we previously had
            const newNumOfLwrDefines = Array.from(output.code.matchAll(LWR_DEFINE_REGEX), (match) => match[1]).length;
            if (numOfLwrDefines !== newNumOfLwrDefines) {
                console.error(`Warning - numOfLwrDefines: ${numOfLwrDefines} doesn't match newNumOfLwrDefines ${newNumOfLwrDefines}.`);
            }
        }
        else {
            // prepend all local bundles to the view bundle
            output.code = codes.map((obj) => obj.code).join('') + output.code;
        }
        const fileName = moduleId.specifier.split('@view/')[1] + '_view.js';
        // write to app dir for republish
        if (this.writeProdBundlesDir) {
            const prodPath = path.join(this.writeProdBundlesDir, 'site', 'prod', 'view', 'en-US', fileName);
            const dirPath = path.dirname(prodPath);
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath, { recursive: true });
            }
            fs.writeFileSync(prodPath, output.code);
        }
        // write overridden view bundles to cache for client hydration
        const cachePath = path.join(this.cacheDir, 'overrides', fileName);
        const dirPath = path.dirname(cachePath);
        if (!fs.existsSync(dirPath)) {
            fs.mkdirSync(dirPath, { recursive: true });
        }
        fs.writeFileSync(cachePath, output.code);
        return output;
    }
    packageProdSource(specifier, newCode, output) {
        // Define the start of the module to replace
        const startMarker = `LWR.define("${specifier}",`;
        const startMarkerAlt = `LWR.define('${specifier}',`;
        // Define the end marker, assuming the next module definition starts with "LWR.define"
        const endMarker = `(function() { LWR.define(`;
        const endMarkerAlt = `LWR.define(`;
        // Find the start index, which will always be the lesser of the two possible indexes
        const startIndex1 = output.code.indexOf(startMarker);
        const startIndex2 = output.code.indexOf(startMarkerAlt);
        let startIndex = this.findIndex(startIndex1, startIndex2);
        if (startIndex === -1) {
            throw new Error(`Module '${specifier}' not found.`);
        }
        // Find the endIndex of the module by locating the start of the next module
        const endIndex1 = output.code.indexOf(endMarker, startIndex + startMarker.length);
        const endIndex2 = output.code.indexOf(endMarkerAlt, startIndex + startMarker.length);
        const endIndex = this.findIndex(endIndex1, endIndex2);
        // If we can't find another module after htis one, assume this is the last module defined in the file
        const moduleEndIndex = endIndex !== -1 ? endIndex : output.code.length;
        // Check if our start index begins with a function wrapper
        if (startIndex - 14 >= 0) {
            const startsWithFunc = output.code.substring(startIndex - 14, startIndex);
            // If it does, make sure we replace that as well
            if (startsWithFunc === '(function() { ') {
                startIndex = startIndex - 14;
            }
        }
        // Update the code
        output.code = output.code.substring(0, startIndex) + newCode + output.code.substring(moduleEndIndex);
    }
}
//# sourceMappingURL=override-bundle-provider.js.map