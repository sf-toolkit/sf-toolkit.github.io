var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/lwr/src/cli/localdev/providers/override-bundle-provider.ts
__markAsModule(exports);
__export(exports, {
  default: () => override_bundle_provider_default
});
var import_bundle_provider = __toModule(require("@lwrjs/static/bundle-provider"));
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var LWR_DEFINE_REGEX = /LWR\.define\(["']([^"']+)["']/g;
var StaticOverrideBundleProvider = class extends import_bundle_provider.default {
  constructor(options, context) {
    super(options, context);
    if (!context.siteMetadata) {
      throw new Error(`[${this.name}] Site metadata was not found`);
    }
    this.writeProdBundlesDir = options.writeProdBundlesDir;
    this.moduleRegistry = context.moduleRegistry;
    this.moduleBundler = context.moduleBundler;
    this.cacheDir = context.config.cacheDir;
    this.staticBundles = Object.keys(context.siteMetadata.getSiteBundles().bundles);
  }
  findIndex(index1, index2) {
    let startIndex;
    if (index1 !== -1) {
      if (index2 !== -1) {
        startIndex = index1 > index2 ? index2 : index1;
      } else {
        startIndex = index1;
      }
    } else {
      startIndex = index2;
    }
    return startIndex;
  }
  async bundle(moduleId, runtimeEnvironment, runtimeParams) {
    const output = await super.bundle(moduleId, runtimeEnvironment, runtimeParams);
    if (!output?.code || !moduleId.specifier.startsWith("@view")) {
      return output;
    }
    const matches = Array.from(output.code.matchAll(LWR_DEFINE_REGEX), (match) => match[1]);
    const numOfLwrDefines = matches.length;
    if (!numOfLwrDefines) {
      return output;
    }
    const locals = (await Promise.all(matches.map(async (specifier) => {
      try {
        const entry = await this.moduleRegistry.getModuleEntry({specifier});
        if (!entry.scope)
          return void 0;
        const isSymLink = import_fs.default.lstatSync(entry.scope).isSymbolicLink();
        return entry?.scope === process.cwd() || isSymLink ? specifier : void 0;
      } catch (err) {
        return void 0;
      }
    }))).filter((s) => s !== void 0);
    const codes = await Promise.all(locals.map(async (specifier) => {
      try {
        const local = await this.moduleBundler.getModuleBundle({specifier}, runtimeEnvironment, runtimeParams, {
          exclude: matches.concat(this.staticBundles)
        });
        return {specifier, code: "(function() { " + local.code + "})();"};
      } catch (err) {
        import_diagnostics.logger.warn(`Failed to override "${specifier}"`);
        throw err;
      }
    }));
    if (this.writeProdBundlesDir) {
      for (let i = 0; i < codes.length; i++) {
        const obj = codes[i];
        this.packageProdSource(obj.specifier, obj.code, output);
      }
      const newNumOfLwrDefines = Array.from(output.code.matchAll(LWR_DEFINE_REGEX), (match) => match[1]).length;
      if (numOfLwrDefines !== newNumOfLwrDefines) {
        console.error(`Warning - numOfLwrDefines: ${numOfLwrDefines} doesn't match newNumOfLwrDefines ${newNumOfLwrDefines}.`);
      }
    } else {
      output.code = codes.map((obj) => obj.code).join("") + output.code;
    }
    const fileName = moduleId.specifier.split("@view/")[1] + "_view.js";
    if (this.writeProdBundlesDir) {
      const prodPath = import_path.default.join(this.writeProdBundlesDir, "site", "prod", "view", "en-US", fileName);
      const dirPath2 = import_path.default.dirname(prodPath);
      if (!import_fs.default.existsSync(dirPath2)) {
        import_fs.default.mkdirSync(dirPath2, {recursive: true});
      }
      import_fs.default.writeFileSync(prodPath, output.code);
    }
    const cachePath = import_path.default.join(this.cacheDir, "overrides", fileName);
    const dirPath = import_path.default.dirname(cachePath);
    if (!import_fs.default.existsSync(dirPath)) {
      import_fs.default.mkdirSync(dirPath, {recursive: true});
    }
    import_fs.default.writeFileSync(cachePath, output.code);
    return output;
  }
  packageProdSource(specifier, newCode, output) {
    const startMarker = `LWR.define("${specifier}",`;
    const startMarkerAlt = `LWR.define('${specifier}',`;
    const endMarker = `(function() { LWR.define(`;
    const endMarkerAlt = `LWR.define(`;
    const startIndex1 = output.code.indexOf(startMarker);
    const startIndex2 = output.code.indexOf(startMarkerAlt);
    let startIndex = this.findIndex(startIndex1, startIndex2);
    if (startIndex === -1) {
      throw new Error(`Module '${specifier}' not found.`);
    }
    const endIndex1 = output.code.indexOf(endMarker, startIndex + startMarker.length);
    const endIndex2 = output.code.indexOf(endMarkerAlt, startIndex + startMarker.length);
    const endIndex = this.findIndex(endIndex1, endIndex2);
    const moduleEndIndex = endIndex !== -1 ? endIndex : output.code.length;
    if (startIndex - 14 >= 0) {
      const startsWithFunc = output.code.substring(startIndex - 14, startIndex);
      if (startsWithFunc === "(function() { ") {
        startIndex = startIndex - 14;
      }
    }
    output.code = output.code.substring(0, startIndex) + newCode + output.code.substring(moduleEndIndex);
  }
};
var override_bundle_provider_default = StaticOverrideBundleProvider;
