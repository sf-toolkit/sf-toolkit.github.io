import { PROTOCOL_FILE, createAmdAlias, getFeatureFlags, getSpecifier, normalizeVersionToUri, } from '@lwrjs/shared-utils';
import { getSsrServices, parseBootstrapSpecifier } from '../identity.js';
import fs from 'fs-extra';
import { fileURLToPath } from 'url';
const LWC_SPECIFIERS = { csr: 'lwc', ssr: '@lwc/engine-server' };
async function readableToString(readable) {
    let result = '';
    for await (const chunk of readable) {
        result += chunk;
    }
    return result;
}
// TODO we will need to look into this caching to support multiple LWR versions
let loaderShimSource;
async function getLoaderShim(resourceRegistry, runtimeEnvironment) {
    if (loaderShimSource !== undefined) {
        return loaderShimSource;
    }
    const specifier = getFeatureFlags().LEGACY_LOADER
        ? 'lwr-loader-shim-legacy.bundle.min.js'
        : 'lwr-loader-shim.bundle.min.js';
    const resource = await resourceRegistry.getResource({ specifier }, runtimeEnvironment);
    if (resource) {
        const { stream } = resource;
        if (stream) {
            loaderShimSource = await readableToString(stream());
            return loaderShimSource;
        }
    }
}
function getLwrConfig(bundleSpecifier, lwrVersion, serverData) {
    // This is the minimum LWR config required for the loader to be created and mountApp to succeed
    return Object.assign({}, {
        autoBoot: true,
        bootstrapModule: `${bundleSpecifier}/v/${lwrVersion}`,
        disableInitDefer: true,
        endpoints: {
            uris: { mapping: '/1/mapping/amd/1/l/en-US/mp/' },
        },
        rootComponents: [],
        serverData, // make getServerData props available during bootstrap
    }, getFeatureFlags().LEGACY_LOADER
        ? {
            baseUrl: 'ssr',
        }
        : {
            baseUrl: '/',
            imports: {
                'any/thing.js': ['any/thing'],
            },
        });
}
// Alias a CSR module specifier to its SSR implementation
// eg: lwc/v/x_y_z -> @lwc/engine-server/v/x_y_z
function aliasLwcEngine(ssrSpecifier, aliases) {
    const csrSpecifier = ssrSpecifier.replace(aliases.ssr, aliases.csr);
    const ssrLwcAlias = createAmdAlias(csrSpecifier, ssrSpecifier);
    // TODO: remove pending TD-0148452
    const unversionedAlias = createAmdAlias(LWC_SPECIFIERS.csr, ssrSpecifier);
    return `${ssrLwcAlias}${unversionedAlias}`;
}
const GLOBALTHIS_LWR = `globalThis.LWR = globalThis.LWR || {};`;
export async function getCode(runtimeEnvironment, serverData, lwrVersion, bundleSpecifier, includedModules, resourceRegistry) {
    const loaderShimSource = await getLoaderShim(resourceRegistry, runtimeEnvironment);
    const lwrConfigString = JSON.stringify(getLwrConfig(bundleSpecifier, lwrVersion, serverData));
    const lwcSpecifier = includedModules.find((m) => m.startsWith(`${LWC_SPECIFIERS.ssr}/v`));
    // SandboxResults interface `errors` contract expects the root cmp specifier.
    const info = parseBootstrapSpecifier(bundleSpecifier);
    const rootCmpSpecifiers = info ? info.rootSpecifiers.join(',') : bundleSpecifier;
    // Order matters:
    //     1. "globalThis.LWR" must be defined prior to executing the shim and loader
    //     2. the lwc module override needs to be defined before lwc is [re]defined in the custom element code (first define wins)
    return [
        GLOBALTHIS_LWR,
        `Object.assign(globalThis.LWR, ${lwrConfigString});`,
        // attaching a custom error handler to catch async bootstrap errors
        `Object.assign(globalThis.LWR, { onError: (err) => globalThis.resolver({ errors: { '${rootCmpSpecifiers}': err.message}})});`,
        loaderShimSource ? loaderShimSource : '',
        lwcSpecifier ? aliasLwcEngine(lwcSpecifier, LWC_SPECIFIERS) : '',
    ];
}
export async function getBundle(specifier, // e.g. "@lwrjs/lwc-ssr/home/root/component"
moduleBundler, routes, runtimeEnvironment, runtimeParams) {
    if (getFeatureFlags().SSR_STATIC_BUNDLES) {
        // concatenate existing bundles SSGed at build time
        return buildBundle(specifier, moduleBundler, routes, runtimeEnvironment, runtimeParams);
    }
    // create a new SSR bundle
    return bundle(specifier, moduleBundler, 
    // Bundle for SSR env if bundle is not the
    {
        ...runtimeEnvironment,
        bundle: true,
    }, runtimeParams, {
        appendExcludes: false,
        // "lwc" is aliased as "@lwc/engine-server" in the AMD SSR bootstrap module
        exclude: ['lwc'],
    }).then(async (bundle) => {
        // Append Files based externals to the SSR bundle
        bundle.code = await appendFileBasedExternals(bundle.code, bundle.bundleRecord.dynamicImports, bundle.bundleRecord.imports, new Set(), new Set());
        return bundle;
    });
}
// Recursively find an file base externals needed for this bundle
async function appendFileBasedExternals(bundleCode, dynamicImports = [], imports = [], visitedBundles, visitedExternals) {
    for (const { specifier, external, externalSrc } of [...imports, ...dynamicImports]) {
        if (!visitedBundles.has(specifier) &&
            (!external || !externalSrc || !visitedExternals.has(externalSrc))) {
            visitedBundles.add(specifier);
            if (external && externalSrc) {
                visitedExternals.add(externalSrc);
                if (externalSrc && externalSrc.startsWith(PROTOCOL_FILE)) {
                    const path = fileURLToPath(externalSrc);
                    const externalBundle = fs.readFileSync(path, { encoding: 'utf-8' }).toString();
                    bundleCode = bundleCode.concat(`\n${externalBundle}`);
                }
            }
        }
    }
    return bundleCode;
}
async function bundle(specifier, moduleBundler, runtimeEnvironment, runtimeParams, bundleConfigOverrides) {
    return await moduleBundler.getModuleBundle({ specifier }, runtimeEnvironment, runtimeParams, bundleConfigOverrides);
}
// Recursively bundle the static imports of a root bundle into a single bundle
async function bundleImports(bundleCode, dynamicImports = [], imports = [], visited, moduleBundler, runtimeEnvironment, runtimeParams) {
    for (const { specifier } of imports) {
        if (!visited.has(specifier)) {
            visited.add(specifier);
            // eslint-disable-next-line no-await-in-loop
            const { code, bundleRecord, version } = await bundle(specifier, moduleBundler, runtimeEnvironment, runtimeParams);
            const bundledCode = getBundledCode(runtimeEnvironment, specifier, version, code);
            bundleCode =
                // eslint-disable-next-line no-await-in-loop
                (await bundleImports(bundledCode, bundleRecord.dynamicImports, bundleRecord.imports, visited, moduleBundler, runtimeEnvironment, runtimeParams)) + bundleCode;
        }
    }
    // Pull in one level of dynamic imports
    for (const { specifier } of dynamicImports) {
        if (!visited.has(specifier)) {
            visited.add(specifier);
            // eslint-disable-next-line no-await-in-loop
            const { code, version } = await bundle(specifier, moduleBundler, runtimeEnvironment, runtimeParams);
            // Add Dynamic Code
            bundleCode += getBundledCode(runtimeEnvironment, specifier, version, code);
        }
    }
    return bundleCode;
}
function getBundledCode(runtimeEnvironment, specifier, version, code) {
    let bundledCode;
    if (runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES) {
        const aliasCode = createAmdAlias(getSpecifier({ specifier, version }), specifier);
        bundledCode = [code, aliasCode].filter(Boolean).join('');
    }
    else {
        bundledCode = code;
    }
    return bundledCode;
}
async function getBundleWithImports(specifier, moduleBundler, runtimeEnvironment, runtimeParams) {
    const { code, bundleRecord } = await bundle(specifier, moduleBundler, runtimeEnvironment, runtimeParams);
    return await bundleImports(code, bundleRecord.dynamicImports, bundleRecord.imports, new Set(['lwc', specifier]), // visited (lwc is excluded)
    moduleBundler, runtimeEnvironment, runtimeParams);
}
// Build a SSR bundle for a root component by concatenating:
// - the bootstrap service modules and static imports
// - the root component bundle and static imports
// - @lwc/engine-server
// - the SSR bundle for the root specifier
async function buildBundle(ssrSpecifier, moduleBundler, routes, runtimeEnvironment, runtimeParams) {
    const { rootSpecifiers, route } = parseBootstrapSpecifier(ssrSpecifier, routes);
    // 0. Get the bundle for each SSR bootstrap service, including all static dependencies
    const ssrServices = getSsrServices(route);
    const serviceBundles = await Promise.all(ssrServices.map((s) => getBundleWithImports(s, moduleBundler, runtimeEnvironment, runtimeParams)));
    const serviceCode = serviceBundles.reduce((all, sc) => all + sc, '');
    // 1. Get the bundle for the root component, including all static dependencies
    let rootCode = '';
    for (const rootSpecifier of rootSpecifiers) {
        // eslint-disable-next-line no-await-in-loop
        rootCode += await getBundleWithImports(rootSpecifier, moduleBundler, runtimeEnvironment, runtimeParams);
        // TODO: remove pending TD-0148452
        if (runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES) {
            // Create an AMD alias to the un-versioned root module
            // if the bundle-metadata for the module doesn't have a version, it will have /v/version-not-provided`
            const aliasSpecifier = getSpecifier({
                specifier: rootSpecifier,
                version: 'version-not-provided',
            });
            const aliasCode = createAmdAlias(aliasSpecifier, rootSpecifier);
            rootCode = [aliasCode, rootCode].join('');
        }
    }
    // 2. Get the bundle for the LWC engine
    const { code: lwcEngineCode, version: lwcVersion } = await bundle(LWC_SPECIFIERS.ssr, moduleBundler, runtimeEnvironment, runtimeParams);
    // 3. Get the bundle for the SSR root component
    // Exclude the LWC engine and root component from this bundle. Use the pre-built bundles fetched above instead.
    const { bundleRecord, code: ssrCode, version: lwrVersion, } = await bundle(ssrSpecifier, moduleBundler, runtimeEnvironment, runtimeParams, {
        appendExcludes: true,
        exclude: [LWC_SPECIFIERS.ssr, ...rootSpecifiers, ...ssrServices],
    });
    // Now concatenate the code gathered above to create the SSR bundle for the root component
    const code = serviceCode + rootCode + lwcEngineCode + ssrCode;
    bundleRecord.includedModules.push(`${LWC_SPECIFIERS.ssr}/v/${normalizeVersionToUri(lwcVersion)}`); // for LWC aliasing
    return {
        bundleRecord,
        code,
        specifier: ssrSpecifier,
        version: lwrVersion,
    };
}
//# sourceMappingURL=amd-utils.js.map