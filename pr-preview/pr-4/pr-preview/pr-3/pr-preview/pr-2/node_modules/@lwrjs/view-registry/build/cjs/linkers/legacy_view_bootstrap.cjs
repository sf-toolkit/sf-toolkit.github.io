var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/linkers/legacy_view_bootstrap.ts
__markAsModule(exports);
__export(exports, {
  getHtmlResources: () => getHtmlResources
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_identity = __toModule(require("@lwrjs/app-service/identity"));
var import_utils = __toModule(require("../utils.cjs"));
var import_utils2 = __toModule(require("./utils.cjs"));
var import_preload_utils = __toModule(require("./preload-utils.cjs"));
function includeIdFactory(bundleConfig) {
  return (moduleRef) => {
    if ((0, import_shared_utils.isExternalSpecifier)(moduleRef.specifier, bundleConfig)) {
      return false;
    }
    return true;
  };
}
async function getHtmlResources(view, viewParams, resourceContext) {
  const {
    runtimeEnvironment,
    runtimeParams,
    moduleRegistry,
    moduleBundler,
    resourceRegistry,
    viewMetadata
  } = resourceContext;
  const {lwrVersion, format, hmrEnabled, bundle, debug, minify} = runtimeEnvironment;
  const {customElements, serverData, serverDebug} = viewMetadata;
  const version = lwrVersion;
  const isAMD = format === "amd";
  const {bundleConfig} = resourceContext;
  const {external = {}, exclude = []} = bundleConfig;
  const groups = isAMD ? bundleConfig.groups || {} : {};
  const getPreloadUri = function(rawSpecifier, uriMap) {
    const {specifier} = (0, import_shared_utils.explodeSpecifier)(rawSpecifier);
    if (Object.keys(external).some((e) => specifier === e))
      return;
    const uri = uriMap[rawSpecifier];
    if (!uri && (exclude.includes(specifier) || (0, import_shared_utils.isGroupie)(specifier, groups))) {
      import_diagnostics.logger.warn({
        label: "view-registry",
        message: `Skipping preload of unknown static import: ${rawSpecifier}`
      });
      return;
    }
    return uri;
  };
  const {
    id: appName,
    bootstrap: {services, module: bootstrapModule, preloadModules = []} = {
      services: [],
      preloadModules: []
    }
  } = view;
  const defRegistry = bundle ? moduleBundler : moduleRegistry;
  const depth = isAMD ? {static: import_shared_utils.GraphDepth.ALL, dynamic: 1} : {static: import_shared_utils.GraphDepth.NONE, dynamic: 0};
  if (isAMD) {
    depth.includeId = includeIdFactory(bundleConfig);
  }
  const appIdentity = {
    appName,
    format: runtimeEnvironment.format,
    resourceType: import_identity.AppResourceEnum.MODULE
  };
  const bootstrapSpecifier = bootstrapModule || (0, import_identity.getAppSpecifier)(appIdentity);
  const moduleResources = [];
  const requiredResources = [];
  const configResources = [];
  const visitedCache = new Map();
  const imports = {};
  const rootComponents = [];
  const requiredAmdModules = [];
  const viewPreloads = {
    uris: [],
    specifiers: [],
    groups: new Map()
  };
  const isSSR = view.bootstrap?.ssr;
  let bootstrapModuleRef, versionedSpecifier = bootstrapSpecifier;
  const customElementsRecords = [];
  const flattenedElements = (0, import_utils2.flattenCustomElements)(customElements, isSSR);
  const viewContainsLiveElements = !isSSR || flattenedElements.some(({props}) => (0, import_shared_utils.getHydrateDirective)(props));
  if (viewContainsLiveElements) {
    if (isAMD) {
      const shimBundle = debug || minify === false ? "lwr-loader-shim-legacy.bundle.js" : "lwr-loader-shim-legacy.bundle.min.js";
      let def = await resourceRegistry.getResource({specifier: shimBundle, version}, runtimeEnvironment, runtimeParams);
      if (!def) {
        let fallbackShimBundle;
        if (shimBundle === "lwr-loader-shim-legacy.bundle.js") {
          fallbackShimBundle = "lwr-loader-shim-legacy.bundle.min.js";
          def = await resourceRegistry.getResource({specifier: fallbackShimBundle, version}, runtimeEnvironment, runtimeParams);
        } else {
          fallbackShimBundle = "lwr-loader-shim-legacy.bundle.js";
          def = await resourceRegistry.getResource({specifier: fallbackShimBundle, version}, runtimeEnvironment, runtimeParams);
        }
        if (!def) {
          throw Error("Failed to find definition of resource: " + shimBundle);
        }
      }
      if (!def.inline && !def.src) {
        throw Error(`Invalid Shim ${shimBundle}: ${JSON.stringify(def)}`);
      }
      requiredResources.push(def);
      const errorShimDef = await resourceRegistry.getResource({specifier: "lwr-error-shim.js", version}, runtimeEnvironment, runtimeParams);
      if (!errorShimDef) {
        throw Error("Failed to find definition of resource: lwr-error-shim.js");
      }
      if (!errorShimDef.inline && !errorShimDef.src) {
        throw Error(`Invalid Shim lwr-error-shim.js: ${JSON.stringify(errorShimDef)}`);
      }
      requiredResources.push(errorShimDef);
    }
    const bootstrapModuleGraph = await (0, import_shared_utils.getModuleGraphs)(bootstrapSpecifier, {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visitedCache);
    bootstrapModuleRef = {
      specifier: bootstrapModuleGraph.graphs[0].specifier,
      flatGraph: bootstrapModuleGraph,
      resources: configResources
    };
    versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
    const uri = bootstrapModuleGraph.uriMap[versionedSpecifier];
    if (!uri) {
      throw Error(`Invalid Module Resource ${versionedSpecifier}`);
    }
    moduleResources.push((0, import_utils.getModuleResourceByUri)(uri, runtimeEnvironment, {isPreload: false, isSSR}));
    for (const depSpecifier of bootstrapModuleGraph.graphs[0].static) {
      const uri2 = getPreloadUri(depSpecifier, bootstrapModuleGraph.uriMap);
      if (uri2) {
        (0, import_preload_utils.setPreloadModulesMeta)(depSpecifier, uri2, groups, viewPreloads);
      }
    }
    if ((0, import_shared_utils.isBundler)(defRegistry)) {
      for (const specifier of preloadModules) {
        await (0, import_preload_utils.getPreloadModulesMeta)(specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams);
      }
    }
    if (isAMD) {
      requiredAmdModules.push(versionedSpecifier);
      imports[versionedSpecifier] = uri;
      for (const staticDep of bootstrapModuleGraph.graphs[0].static) {
        const uri2 = bootstrapModuleGraph.uriMap[staticDep];
        imports[staticDep] = uri2;
        if (services && services.length) {
          requiredAmdModules.push(staticDep);
        }
      }
      for (const dynamicDep of bootstrapModuleGraph.graphs[0].dynamicRefs) {
        const uri2 = bootstrapModuleGraph.uriMap[dynamicDep];
        if (uri2) {
          imports[dynamicDep] = uri2;
        } else {
          import_diagnostics.logger.warn({
            label: `view-registry`,
            message: `Skipping unknown dynamic import: ${dynamicDep}`
          });
        }
      }
    }
  }
  await Promise.all(flattenedElements.map(async ({tagName: element, props}) => {
    const graph = await (0, import_shared_utils.getModuleGraphs)((0, import_shared_utils.kebabCaseToModuleSpecifier)(element), {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams ? runtimeParams : {}, visitedCache);
    customElementsRecords.push({elementName: element, flatGraph: graph});
    if (!isSSR || (0, import_shared_utils.getHydrateDirective)(props)) {
      const specifier = graph.graphs[0].specifier;
      const uri = graph.uriMap[specifier];
      (0, import_preload_utils.setPreloadModulesMeta)(specifier, uri, groups, viewPreloads);
      if (bundle) {
        for (const depSpecifier of graph.graphs[0].static) {
          const uri2 = getPreloadUri(depSpecifier, graph.uriMap);
          if (uri2) {
            (0, import_preload_utils.setPreloadModulesMeta)(depSpecifier, uri2, groups, viewPreloads);
          }
        }
      }
      rootComponents.push(specifier);
      imports[specifier] = uri;
      if (isAMD) {
        for (const staticDep of graph.graphs[0].static) {
          const uri2 = graph.uriMap[staticDep];
          imports[staticDep] = uri2;
        }
        for (const dynamicDep of graph.graphs[0].dynamicRefs) {
          const uri2 = graph.uriMap[dynamicDep];
          imports[dynamicDep] = uri2;
        }
      }
    }
  }));
  if (viewContainsLiveElements) {
    configResources.unshift((0, import_utils2.getViewBootstrapConfigurationResource)({
      id: view.id,
      url: viewParams?.page?.url,
      configAsSrc: view.bootstrap?.configAsSrc || false,
      mixedMode: view.bootstrap?.mixedMode || false
    }, {
      appId: appIdentity.appName,
      bootstrapModule: versionedSpecifier,
      autoBoot: view.bootstrap?.autoBoot === false ? false : true,
      importMappings: {
        imports,
        default: (0, import_shared_utils.getModuleUriPrefix)(runtimeEnvironment, runtimeParams)
      },
      rootComponents,
      serverData,
      ...isAMD && {requiredModules: requiredAmdModules},
      ...isAMD && {preloadModules: viewPreloads.specifiers}
    }, runtimeEnvironment, runtimeParams, serverDebug?.message));
  }
  if (!isAMD && hmrEnabled) {
    configResources.unshift((0, import_utils2.getViewHmrConfigurationResource)(view, viewMetadata));
  }
  const dedupedUris = [...new Set(viewPreloads.uris)];
  for (const preloadUri of dedupedUris) {
    moduleResources.push((0, import_utils.getModuleResourceByUri)(preloadUri, runtimeEnvironment, {isPreload: true, isSSR}));
  }
  const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(import_utils.generateHtmlTag));
  return {
    partial: htmlResources.join("\n"),
    viewRecord: {
      resources: requiredResources,
      customElements: customElementsRecords,
      bootstrapModule: bootstrapModuleRef
    }
  };
}
