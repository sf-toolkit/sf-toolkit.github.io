import fs from 'fs-extra';
import path from 'path';
import { logger } from '@lwrjs/diagnostics';
import { walkLocaleFallbacks } from '@lwrjs/shared-utils';
const DEFAULT_KEY = 'default';
/**
 * De-duplicate generated bundles
 *
 * @param siteRoot The root folder for generated bundles
 */
export async function dedupeBundles(siteRoot, i18n) {
    // Read the bundle site metadata
    const bundleMetadataFilePath = path.join(siteRoot, '/.metadata/bundle-metadata.json');
    const siteBundles = await fs.readJSON(bundleMetadataFilePath);
    logger.info({
        label: `dedupeBundles`,
        message: `Deduplicating ${Object.keys(siteBundles.bundles).length} bundles`,
    });
    // Group the bundles by locale
    const groupedBundles = groupBundlesByLocales(siteBundles);
    logger.debug({
        label: `dedupeBundles`,
        message: `Found ${Object.keys(groupedBundles).length} grouped bundles`,
    });
    const updatedBundleMetadata = { bundles: {} };
    const updatedBundles = updatedBundleMetadata.bundles;
    for (const specifier of Object.keys(groupedBundles)) {
        const variants = groupedBundles[specifier];
        const defaultVariant = variants[DEFAULT_KEY];
        if (defaultVariant) {
            updatedBundles[specifier] = defaultVariant;
            const defaultSource = String(fs.readFileSync(path.join(siteRoot, defaultVariant.path)));
            // Wite out each variant
            for (const variantKey of Object.keys(variants)) {
                if (variantKey !== DEFAULT_KEY) {
                    // Find the first source that does not match its parent
                    let dedupeSource = false;
                    // Read the current variant source
                    const variant = variants[variantKey];
                    const variantSource = String(fs.readFileSync(path.join(siteRoot, variant.path)));
                    const localeId = extractLocale(variantKey);
                    // If this locale is n
                    if (localeId) {
                        // eslint-disable-next-line no-await-in-loop
                        dedupeSource = await walkLocaleFallbacks(localeId, i18n, async (curLocale) => {
                            // If this is the current locale skip
                            if (curLocale === localeId) {
                                return false;
                            }
                            // If this is a default local test against the read default
                            if (curLocale === i18n.defaultLocale) {
                                return variantSource === defaultSource;
                            }
                            // See if there is a variant for the current locale
                            const curVariant = variants[`l/${curLocale}`];
                            if (curVariant) {
                                const curPath = path.join(siteRoot, curVariant.path);
                                if (await fs.pathExists(curPath)) {
                                    const curVariantSource = String(fs.readFileSync(curPath));
                                    return variantSource === curVariantSource;
                                }
                            }
                            return false;
                        });
                    }
                    if (dedupeSource) {
                        logger.debug({
                            label: `dedupeBundles`,
                            message: `Remove duplicate variant ${specifier}|${variantKey}`,
                        });
                        fs.removeSync(path.join(siteRoot, variant.path));
                    }
                    else {
                        // keep the variant in the metadata
                        const variant = variants[variantKey];
                        updatedBundles[`${specifier}|${variantKey}`] = variant;
                    }
                }
            }
        }
    }
    logger.info({
        label: `dedupeBundles`,
        message: `Deduplicated down to ${Object.keys(updatedBundleMetadata.bundles).length} bundles`,
    });
    // Save the updated bundle metadata
    await fs.writeJSON(bundleMetadataFilePath, updatedBundleMetadata, { spaces: 2 });
    // Clean up empty folders
    deleteEmptyFolders(siteRoot);
}
const LOCALE_PATTERN = /(?:^|\/)l\/([\w-_]+)/;
/**
 * Extract the locale definition from a variant key 'l/{localeId}'
 */
function extractLocale(variantKey) {
    const match = variantKey.match(LOCALE_PATTERN);
    if (match) {
        return match[1]; // The 'key' is captured in the first capture group
    }
    return undefined;
}
function groupBundlesByLocales(siteBundles) {
    const groupedBundles = {};
    for (const specifier of Object.keys(siteBundles.bundles)) {
        const parts = specifier.split('|');
        // Extract the desired parts
        const firstPart = parts[0];
        const secondPart = parts.length > 1 ? parts[1] : DEFAULT_KEY;
        logger.debug({
            label: `dedupeBundles`,
            message: `${specifier} -> groupedBundles[${firstPart}][${secondPart}]`,
        });
        if (!groupedBundles[firstPart]) {
            groupedBundles[firstPart] = {};
        }
        groupedBundles[firstPart][secondPart] = siteBundles.bundles[specifier];
    }
    return groupedBundles;
}
function deleteEmptyFolders(directory) {
    if (!fs.existsSync(directory)) {
        logger.warn({ label: `dedupeBundles`, message: `Directory does not exist: ${directory}` });
        return;
    }
    const files = fs.readdirSync(directory);
    if (files.length === 0) {
        fs.rmdirSync(directory);
        logger.debug({ label: `dedupeBundles`, message: `Deleted empty folder: ${directory}` });
        return;
    }
    files.forEach((file) => {
        const filePath = path.join(directory, file);
        const isDirectory = fs.statSync(filePath).isDirectory();
        if (isDirectory) {
            deleteEmptyFolders(filePath);
        }
    });
    // Check if the directory is empty after deleting its subdirectories
    const updatedFiles = fs.readdirSync(directory);
    if (updatedFiles.length === 0) {
        fs.rmdirSync(directory);
        logger.debug({ label: `dedupeBundles`, message: `Deleted empty folder: ${directory}` });
    }
}
//# sourceMappingURL=dedupe-bundles.js.map