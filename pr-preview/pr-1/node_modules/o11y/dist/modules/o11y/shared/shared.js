class Utility {
    constructor() {
        this.notImplemented = 'Method not implemented.';
        const performanceExists = typeof performance !== 'undefined';
        if (performanceExists) {
            if (performance.timeOrigin) {
                this._timeOrigin = performance.timeOrigin;
            }
            else {
                this._timeOrigin = Date.now();
            }
        }
        else {
            this._timeOrigin = Date.now();
        }
        const timeOrigin = this._timeOrigin;
        if (performanceExists && typeof performance.now === 'function') {
            this.perfNow = performance.now.bind(performance);
            this.time = () => {
                const perfNow = this.perfNow();
                return { tsNow: timeOrigin + perfNow, perfNow, timeOrigin };
            };
        }
        else {
            this.perfNow = () => {
                return Date.now() - timeOrigin;
            };
            this.time = () => {
                const perfNow = this.perfNow();
                return { tsNow: Date.now(), perfNow, timeOrigin };
            };
        }
    }
    get isProduction() {
        return Utility._isProduction;
    }
    markProduction(value) {
        Utility._isProduction = value !== null && value !== void 0 ? value : true;
    }
    _checkArgument(argument, argKind) {
        if (typeof argKind === 'string') {
            return typeof argument === argKind;
        }
        if (typeof argKind === 'function') {
            return argument instanceof argKind;
        }
        if (Array.isArray(argKind)) {
            return argKind.some((arg) => this._checkArgument(argument, arg));
        }
        throw new Error(`Invalid argKind ${argKind}`);
    }
    requireArgument(argument, argumentName, argKind) {
        let disallowed = argument === undefined || argument === null || argument === '';
        const kindSpecified = argKind !== undefined;
        if (!disallowed && kindSpecified) {
            disallowed = !this._checkArgument(argument, argKind);
        }
        if (disallowed) {
            throw new Error(`${argumentName} argument is required${kindSpecified ? ' and must be of a supported type.' : '.'}`);
        }
    }
    requireArgumentIfDefined(argument, argumentName, argKind) {
        if (argument === undefined) {
            return false;
        }
        const disallowed = argument === null ||
            argument === '' ||
            !this._checkArgument(argument, argKind);
        if (disallowed) {
            throw new Error(`${argumentName} argument, if defined, must be of a supported type.`);
        }
        return true;
    }
    checkForDenyListedValues(argument, argumentName, denyList) {
        if (denyList.some((x) => argument === x)) {
            throw new Error(`The value ${argument} isn't allowed for ${argumentName} argument.`);
        }
    }
    checkForReservedCharacters(argument, argumentName, reservedChars) {
        if (argument && reservedChars.some((c) => argument.indexOf(c) >= 0)) {
            throw new Error(`The argument ${argumentName} isn't allowed to contain characters from ['${reservedChars.join(', ')}']. Received: ${argument}.`);
        }
    }
    generateUniqueId(length = 16) {
        const chars = [];
        const digits = '0123456789abcdef';
        if (!(length === undefined || length > 0)) {
            throw new Error('If specified, the argument "length" must be a positive integer');
        }
        for (let i = 0; i < length; i++) {
            const rand = Math.floor(Math.random() * 16);
            chars.push(digits[rand]);
        }
        return chars.join('');
    }
    getXpath(_element) {
        function hasSameSibs(elm) {
            const name = elm.localName;
            while (elm.nextElementSibling) {
                elm = elm.nextElementSibling;
                if (elm.localName === name) {
                    return true;
                }
            }
            return false;
        }
        function idx(sib, name) {
            if (sib) {
                return (idx(sib.previousElementSibling, name || sib.localName) +
                    (sib.localName === name ? 1 : 0));
            }
            return 1;
        }
        function segs(elm) {
            if (!elm || elm.nodeType !== 1) {
                return [''];
            }
            const nodeValue = idx(elm) > 1 || hasSameSibs(elm)
                ? `${elm.localName.toLowerCase()}[${idx(elm)}]`
                : elm.localName.toLowerCase();
            return [...segs(elm.parentNode), nodeValue];
        }
        return segs(_element).join('/');
    }
    getAge(timestamp) {
        return timestamp - this._timeOrigin;
    }
    getConnectionType() {
        var _a;
        let connectionType;
        if (typeof navigator !== 'undefined') {
            const expNav = navigator;
            connectionType = (_a = expNav === null || expNav === void 0 ? void 0 : expNav.connection) === null || _a === void 0 ? void 0 : _a.effectiveType;
        }
        return connectionType;
    }
    clone(value) {
        return JSON.parse(JSON.stringify(value));
    }
    definedValueOrDefault(value, defaultValue) {
        return value !== undefined ? value : defaultValue;
    }
    getGlobal() {
        if (typeof globalThis === 'object') {
            return globalThis;
        }
        if (typeof self === 'object') {
            return self;
        }
        throw new Error('Unable to locate globalThis or self');
    }
    getIsBeaconSupported() {
        var _a;
        const g = this.getGlobal();
        return typeof ((_a = g.navigator) === null || _a === void 0 ? void 0 : _a.sendBeacon) === 'function' && typeof g.Blob === 'function';
    }
    estimateObjectSize(object) {
        const objectSet = new Set();
        const stack = [object];
        let bytes = 0;
        while (stack.length) {
            const value = stack.pop();
            if (typeof value === 'boolean') {
                bytes += 4;
            }
            else if (typeof value === 'string') {
                bytes += value.length * 2;
            }
            else if (typeof value === 'number') {
                bytes += 8;
            }
            else if (value instanceof Uint8Array ||
                value instanceof Uint8ClampedArray ||
                value instanceof Uint16Array ||
                value instanceof Uint32Array ||
                value instanceof Int8Array ||
                value instanceof Int16Array ||
                value instanceof Int32Array ||
                value instanceof Float32Array ||
                value instanceof Float64Array) {
                bytes += value.byteLength;
            }
            else if (typeof value === 'object') {
                const obj = value;
                if (!objectSet.has(obj)) {
                    objectSet.add(obj);
                    for (const key in obj) {
                        stack.push(obj[key]);
                    }
                }
            }
        }
        return bytes;
    }
    noProdThrow(e) {
        if (utility.isProduction) {
            return;
        }
        throw e;
    }
    isAllowedOrigin(input, allowed) {
        return (Array.isArray(allowed) &&
            allowed.some((origin) => origin === '*' ||
                input === origin ||
                (origin instanceof RegExp && origin.test(input))));
    }
    roundNumber(value, decimals) {
        const pow = Math.pow(10, decimals);
        return Math.round(value * pow) / pow;
    }
    roundNumbersInObject(obj, decimals) {
        if (obj) {
            Object.entries(obj).forEach(([key, value]) => {
                if (typeof value === 'number') {
                    obj[key] = this.roundNumber(value, decimals);
                }
            });
        }
    }
    tryGetAbsoluteUrl(url) {
        if ((url === null || url === void 0 ? void 0 : url.startsWith('/')) && typeof window === 'object') {
            return window.location.origin + url;
        }
        return url;
    }
}
Utility._isProduction = true;
const _utility = new Utility();
const global = _utility.getGlobal();
_utility.markProduction(global === null || global === void 0 ? void 0 : global.__O11Y_IS_PROD__);
const utility = Object.freeze(_utility);

class UpCounterImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags, createdOn, lastUpdatedOn, value) {
        this._name = _name;
        this._ownerName = _ownerName;
        this._ownerAppName = _ownerAppName;
        this._tags = _tags;
        this._value = 0;
        this._createdOn = createdOn === undefined ? utility.time().tsNow : createdOn;
        if (lastUpdatedOn !== undefined) {
            this._lastUpdatedOn = lastUpdatedOn;
        }
        if (value !== undefined) {
            this._value = value;
        }
    }
    getName() {
        return this._name;
    }
    getCreatedOn() {
        return this._createdOn;
    }
    getLastUpdatedOn() {
        return this._lastUpdatedOn;
    }
    getData() {
        return this._value;
    }
    increment(value = 1) {
        if (typeof value === 'number' && value > 0) {
            this._value += Math.round(value);
            this._lastUpdatedOn = utility.time().tsNow;
            return;
        }
        throw new Error('UpCounter can only increment positive numbers.');
    }
    reset() {
        this._lastUpdatedOn = undefined;
        this._value = 0;
    }
    getOwnerName() {
        return this._ownerName;
    }
    getOwnerAppName() {
        return this._ownerAppName;
    }
    getTags() {
        return this._tags;
    }
}

const co11yName = 'co11y';
class Co11yImpl {
    constructor() {
        this._upCounters = new Map();
        this._ownerAppName = co11yName;
    }
    _addOrUpdateCounter(operation, ownerName, status) {
        if (!operation) {
            return;
        }
        const sortedTags = { status };
        const key = `${this._ownerAppName}:${ownerName}:${operation}${JSON.stringify(sortedTags)}`;
        let instrument = this._upCounters.get(key);
        if (!instrument) {
            instrument = new UpCounterImpl(operation, ownerName, this._ownerAppName, sortedTags);
            this._upCounters.set(key, instrument);
        }
        instrument.increment();
    }
    success(operation, ownerName) {
        this._addOrUpdateCounter(operation, ownerName, 'success');
    }
    exception(operation, ownerName) {
        this._addOrUpdateCounter(operation, ownerName, 'error');
    }
    getBucketHistograms() {
        return [];
    }
    getUpCounters() {
        return Array.from(this._upCounters.values()).filter((m) => m.getLastUpdatedOn());
    }
    getValueRecorders() {
        return [];
    }
    setOwnerAppName(ownerAppName) {
        this._ownerAppName = ownerAppName;
    }
}
const co11y = new Co11yImpl();

class LazyMapToList {
    constructor(maxSize) {
        this._lazyMap = new Map();
        if (maxSize !== undefined) {
            if (typeof maxSize === 'number' && maxSize > 0) {
                this._maxSize = Math.ceil(maxSize);
                return;
            }
            throw new Error('maxSize must be a positive number');
        }
    }
    get maxSize() {
        return this._maxSize;
    }
    get size() {
        return this._lazyMap.size;
    }
    push(key, value) {
        let buffer = this._lazyMap.get(key);
        if (!buffer) {
            if (this.maxSize !== undefined && this.size === this.maxSize) {
                return false;
            }
            buffer = new Array();
            this._lazyMap.set(key, buffer);
        }
        buffer.push(value);
        return true;
    }
    getMessages(key, extract) {
        const msgs = this._lazyMap.get(key);
        if (extract && this._lazyMap.has(key)) {
            this._lazyMap.set(key, []);
        }
        return msgs || [];
    }
    getAllMessages(extract) {
        const map = new Map();
        for (const [key, value] of this._lazyMap.entries()) {
            if (value.length) {
                map.set(key, this.getMessages(key, extract));
            }
        }
        return map;
    }
    extractMessages(key) {
        return this.getMessages(key, true);
    }
    extractAllMessages() {
        return this.getAllMessages(true);
    }
    get totalItemCount() {
        let count = 0;
        for (const array of this._lazyMap.values()) {
            count += array.length;
        }
        return count;
    }
}

class SchemaUtil {
    getSchemaId(schema) {
        return `${schema.namespace}.${schema.name}`;
    }
    isInternal(schema) {
        return (schema === null || schema === void 0 ? void 0 : schema.namespace) === 'sf.instrumentation';
    }
    makePayload(schema, data, onlyIfBoth = true) {
        if (!onlyIfBoth || (schema !== undefined && data !== undefined)) {
            return {
                schema,
                payload: data
            };
        }
        return undefined;
    }
    checkSchema(schema) {
        utility.requireArgument(schema, 'schema', 'object');
        utility.requireArgument(schema.namespace, 'schema.namespace', 'string');
        utility.requireArgument(schema.name, 'schema.name', 'string');
        utility.requireArgument(schema.pbjsSchema, 'schema.pbjsSchema', 'object');
        return this._getTokens(schema);
    }
    _getTokens(schema) {
        const parts = schema.namespace.split('.');
        if (parts.length !== 2) {
            throw new Error(`Schema "${this.getSchemaId(schema)}" must have a namespace of the form "domain.feature".`);
        }
        return {
            domain: parts[0],
            feature: parts[1],
            message: schema.name
        };
    }
    _getAnyNestedObject(schema, scopes) {
        return scopes.reduce((prev, currentScope) => {
            const descriptor = prev.nested;
            if (descriptor) {
                const ano = descriptor[currentScope];
                if (ano) {
                    return ano;
                }
            }
            throw new Error(`Cannot locate ${scopes.join('.')} in schema with ID ${this.getSchemaId(schema)}`);
        }, schema.pbjsSchema);
    }
    getTypes(schema) {
        const schemaTokens = this.checkSchema(schema);
        const namespace = this._getAnyNestedObject(schema, [
            schemaTokens.domain,
            schemaTokens.feature
        ]);
        const descriptor = namespace.nested;
        if (!descriptor) {
            throw new Error(`Cannot parse schema with ID ${this.getSchemaId(schema)}`);
        }
        return descriptor;
    }
    getType(schema, messageName) {
        utility.requireArgument(messageName, 'messageName', 'string');
        const descriptor = this.getTypes(schema);
        const message = descriptor[messageName];
        if (!message) {
            throw new Error(`Cannot locate message ${messageName} in schema with ID ${this.getSchemaId(schema)}`);
        }
        return message;
    }
    getOptions(schema, messageName, fieldName) {
        if (fieldName) {
            utility.requireArgument(messageName, 'messageName', 'string');
        }
        const schemaTokens = this.checkSchema(schema);
        if (!messageName) {
            const namespace = this._getAnyNestedObject(schema, [
                schemaTokens.domain,
                schemaTokens.feature
            ]);
            return namespace.options;
        }
        const type = this.getType(schema, messageName);
        if (!fieldName) {
            return type.options;
        }
        const field = type.fields[fieldName];
        if (!field) {
            const schemaId = this.getSchemaId(schema);
            throw new Error(`Cannot locate field ${fieldName} in message ${messageName} in schema with ID ${schemaId}`);
        }
        return field.options;
    }
    getExtraFields(schema, data) {
        const { message } = this._getTokens(schema);
        const types = this.getTypes(schema);
        const fields = types[message]['fields'];
        const fieldSet = new Set(Object.keys(fields));
        const extraFields = data !== null && data !== undefined
            ? Object.keys(data).filter((key) => !fieldSet.has(key))
            : [];
        return extraFields;
    }
}
const schemaUtil = new SchemaUtil();

const maxStringLengthAppLimit = 10000;
const maxItemCountAppLimit = 10000;
const minUnsigned = 0;
const maxFourBytes = 2147483647;
const minFourBytes = -2147483648;
const maxFourBytesUnsigned = 4294967295;
const maxEightBytes = 9223372036854776000;
const minEightBytes = -9223372036854776001;
const maxEightBytesUnsigned = 18446744073709552000;
class ValidationEntry {
    constructor(errorCode, fields, expected, received) {
        this.errorCode = errorCode;
        this.fields = fields;
        this.expected = expected;
        this.received = received;
    }
    asMessage(schemaId) {
        const key = this.fields[0] +
            this.fields
                .slice(1)
                .reduce((prev, current) => Number(current) >= 0 ? `${prev}[${current}]` : `${prev}.${current}`, '');
        let msg;
        switch (this.errorCode) {
            case 1:
                msg = 'Repeated field must be an array';
                break;
            case 2:
                msg = `Expected type ${this.expected} but received type ${this.received}`;
                break;
            case 3:
                msg = 'Value must be finite';
                break;
            case 4:
                msg = 'Value is out of range for its type';
                break;
            case 5:
                msg = 'Bytes array is malformed';
                break;
            case 6:
                msg = 'Exceeded app limit for maximum string length';
                break;
            case 7:
                msg = 'Exceeded app limit for item count';
                break;
            case 12:
                msg = 'Value must be an integer';
                break;
            case 13:
                msg = 'Values like null or undefined are not allowed for items in repeated fields';
                break;
            default:
                msg = `Unknown error code: ${this.errorCode}`;
                break;
        }
        return `Schema ${schemaId} on field "${key}": ${msg}`;
    }
}
class LogValidator {
    validate(schema, data, noThrow = false) {
        const schemaTokens = schemaUtil.checkSchema(schema);
        utility.requireArgument(data, 'data', 'object');
        const schemaId = schemaUtil.getSchemaId(schema);
        const errorInfos = new Array();
        const nestedSchema = schemaUtil.getTypes(schema);
        this._validateFields(errorInfos, [], data, nestedSchema[schemaTokens.message], nestedSchema, schemaId);
        if (errorInfos.length && !noThrow) {
            throw new Error(errorInfos[0].asMessage(schemaId));
        }
        return errorInfos;
    }
    _validateFields(errorInfos, fieldNames, data, message, descriptor, schemaId) {
        const oneofs = message.oneofs || {};
        const fields = message.fields || {};
        for (const key in data) {
            const value = data[key];
            if (value !== undefined && value !== null) {
                const mft = (fieldType, isRepeated, isItem) => this._matchFieldTypes(errorInfos, [...fieldNames, key], value, fieldType, descriptor, schemaId, key, isRepeated, isItem);
                if (oneofs[key]) {
                    mft(fields[oneofs[key].oneof[0]].type);
                }
                else if (fields[key]) {
                    mft(fields[key].type, fields[key].rule === 'repeated');
                }
            }
        }
    }
    _matchFieldTypes(errorInfos, fieldNames, fieldDataValue, protobufType, descriptor, schemaId, key, isRepeated, isItem) {
        let errorCode;
        if (isRepeated) {
            if (Array.isArray(fieldDataValue)) {
                if (fieldDataValue.length > maxItemCountAppLimit) {
                    errorCode = 7;
                }
                fieldDataValue.forEach((value, index) => {
                    this._matchFieldTypes(errorInfos, [...fieldNames, index.toString()], value, protobufType, descriptor, schemaId, key, undefined, true);
                });
            }
            else {
                errorCode = 1;
            }
        }
        else if (fieldDataValue == null || fieldDataValue === undefined) {
            if (isItem) {
                errorCode = 13;
            }
        }
        else {
            let numOpts;
            let javaScriptType;
            switch (protobufType) {
                case 'string':
                    javaScriptType = 'string';
                    if (fieldDataValue.length > maxStringLengthAppLimit) {
                        errorCode = 6;
                    }
                    break;
                case 'bytes':
                    javaScriptType = 'object';
                    if (!(fieldDataValue instanceof Uint8Array)) {
                        errorCode = 5;
                    }
                    break;
                case 'bool':
                    javaScriptType = 'boolean';
                    break;
                case 'uint32':
                    javaScriptType = 'number';
                    numOpts = {
                        min: minUnsigned,
                        max: maxFourBytesUnsigned,
                        isInt: true,
                        isItem
                    };
                    break;
                case 'int32':
                case 'sint32':
                case 'fixed32':
                case 'sfixed32':
                    javaScriptType = 'number';
                    numOpts = {
                        min: minFourBytes,
                        max: maxFourBytes,
                        isInt: true,
                        isItem
                    };
                    break;
                case 'uint64':
                    javaScriptType = 'number';
                    numOpts = {
                        min: minUnsigned,
                        max: maxEightBytesUnsigned,
                        isInt: true,
                        isItem
                    };
                    break;
                case 'fixed64':
                case 'sfixed64':
                case 'int64':
                case 'sint64':
                    javaScriptType = 'number';
                    numOpts = {
                        min: minEightBytes,
                        max: maxEightBytes,
                        isInt: true,
                        isItem
                    };
                    break;
                case 'double':
                case 'float':
                    javaScriptType = 'number';
                    numOpts = {
                        min: Number.NEGATIVE_INFINITY,
                        max: Number.POSITIVE_INFINITY,
                        isInt: false,
                        isItem
                    };
                    break;
                default:
                    if (new Set(Object.keys(descriptor)).has(protobufType)) {
                        this._validateFields(errorInfos, fieldNames, fieldDataValue, descriptor[protobufType], descriptor, schemaId);
                        javaScriptType = 'object';
                    }
                    break;
            }
            if (typeof fieldDataValue !== javaScriptType) {
                errorInfos.push(new ValidationEntry(2, fieldNames, protobufType, typeof fieldDataValue));
            }
            else if (numOpts) {
                if (numOpts.isInt && !Number.isFinite(fieldDataValue)) {
                    errorCode = 3;
                }
                else if (numOpts.isInt && !Number.isInteger(fieldDataValue)) {
                    errorCode = 12;
                }
                else if (!(!numOpts.isInt && Number.isNaN(fieldDataValue)) &&
                    !(fieldDataValue >= numOpts.min && fieldDataValue <= numOpts.max)) {
                    errorCode = 4;
                }
            }
        }
        if (errorCode) {
            errorInfos.push(new ValidationEntry(errorCode, fieldNames));
        }
    }
}
const logValidator = new LogValidator();

class MetricsUtility {
    _getMetricTags(metric) {
        const tags = metric.getTags();
        if (tags) {
            return Object.entries(tags).map((entry) => {
                const mt = {
                    name: entry[0],
                    value: entry[1].toString()
                };
                return mt;
            });
        }
        return undefined;
    }
    getUpCounters(metrics, reset = true) {
        return metrics.map((metric) => {
            const data = {
                name: metric.getName(),
                createdTimestamp: metric.getCreatedOn(),
                lastUpdatedTimestamp: metric.getLastUpdatedOn(),
                value: metric.getData(),
                ownerName: metric.getOwnerName(),
                ownerAppName: metric.getOwnerAppName(),
                tags: this._getMetricTags(metric)
            };
            if (reset) {
                metric.reset();
            }
            return data;
        });
    }
    getValueRecorders(metrics, reset = true) {
        return metrics.map((metric) => {
            const data = {
                name: metric.getName(),
                createdTimestamp: metric.getCreatedOn(),
                lastUpdatedTimestamp: metric.getLastUpdatedOn(),
                values: metric.getData(),
                ownerName: metric.getOwnerName(),
                ownerAppName: metric.getOwnerAppName(),
                tags: this._getMetricTags(metric)
            };
            if (reset) {
                metric.reset();
            }
            return data;
        });
    }
    getBucketHistograms(metrics, reset = true) {
        return metrics.map((metric) => {
            const data = {
                name: metric.getName(),
                createdTimestamp: metric.getCreatedOn(),
                lastUpdatedTimestamp: metric.getLastUpdatedOn(),
                values: metric.getData(),
                buckets: metric.getBuckets(),
                ownerName: metric.getOwnerName(),
                ownerAppName: metric.getOwnerAppName(),
                tags: this._getMetricTags(metric)
            };
            if (reset) {
                metric.reset();
            }
            return data;
        });
    }
    getMetricsTags(array) {
        const obj = {};
        array.forEach((tag) => {
            obj[tag.name] = tag.value;
        });
        return obj;
    }
}
const metricsUtility = Object.freeze(new MetricsUtility());

class PayloadUtility {
    checkInputs(schema, data) {
        schemaUtil.checkSchema(schema);
        utility.requireArgument(data, 'data', 'object');
        let vEntries;
        let savedUserPayload;
        if (data.userPayload !== undefined && schemaUtil.isInternal(schema)) {
            savedUserPayload = data.userPayload;
            vEntries = logValidator.validate(savedUserPayload.schema, savedUserPayload.payload, true);
            this._processValidationResults(schemaUtil.getSchemaId(savedUserPayload.schema), savedUserPayload.payload, vEntries);
            data.userPayload = undefined;
        }
        vEntries = logValidator.validate(schema, data, true);
        this._processValidationResults(schemaUtil.getSchemaId(schema), data, vEntries);
        if (savedUserPayload !== undefined) {
            data.userPayload = savedUserPayload;
        }
    }
    getExtraFields(schema, data) {
        utility.requireArgument(data, 'data', 'object');
        const ignoredFields = [];
        const subPayload = data.userPayload;
        if (subPayload !== undefined && schemaUtil.isInternal(schema)) {
            ignoredFields.push(...schemaUtil.getExtraFields(subPayload.schema, subPayload.payload));
        }
        ignoredFields.push(...schemaUtil.getExtraFields(schema, data));
        return ignoredFields;
    }
    getPayloadFromProvider(provider, args) {
        const payload = (provider === null || provider === void 0 ? void 0 : provider.getPayload(args)) || undefined;
        if (payload) {
            this.checkInputs(payload.schema, payload.payload);
        }
        return payload;
    }
    _processValidationResults(schemaId, data, ventries) {
        for (let i = 0; i < ventries.length; i += 1) {
            const ei = ventries[i];
            if (ei.errorCode == 6 ||
                ei.errorCode == 7) {
                const lfi = ei.fields.length - 1;
                const obj = this._traverseFields(data, ei.fields.slice(0, lfi));
                const field = ei.fields[lfi];
                if (ei.errorCode == 6) {
                    obj[field] = obj[field].substring(0, maxStringLengthAppLimit);
                }
                else {
                    obj[field].splice(maxItemCountAppLimit);
                }
            }
            else {
                throw new Error(ei.asMessage(schemaId));
            }
        }
    }
    _traverseFields(data, fields) {
        if (!fields.length) {
            return data;
        }
        return this._traverseFields(data[fields[0]], fields.slice(1));
    }
}
const payloadUtility = Object.freeze(new PayloadUtility());

const o11y = 'o11y';
class PublicSafety {
    constructor(_errorCounter) {
        this._errorCounter = _errorCounter;
        this._safeCatchMode = false;
    }
    _callCo11y(options, hasException) {
        if (hasException) {
            co11y.exception(options === null || options === void 0 ? void 0 : options.op, o11y);
        }
        else {
            co11y.success(options === null || options === void 0 ? void 0 : options.op, o11y);
        }
    }
    tryCatch(fn, options) {
        let ex;
        try {
            fn();
        }
        catch (err) {
            ex = true;
            this._prodSafeCatch(err);
        }
        finally {
            this._callCo11y(options, ex);
        }
    }
    tryCatchReturn(fn, noopValue, options) {
        let ex;
        try {
            utility.requireArgument(noopValue, 'noopValue');
            return fn();
        }
        catch (err) {
            ex = true;
            this._prodSafeCatch(err);
            return noopValue;
        }
        finally {
            this._callCo11y(options, ex);
        }
    }
    _prodSafeCatch(error) {
        let allowThrow;
        try {
            allowThrow = !utility.isProduction;
            if (allowThrow) {
                throw error;
            }
            if (this._safeCatchMode) {
                this._safeCatchMode = false;
                throw new Error('Internal error in prodSafeCatch.');
            }
            this._safeCatchMode = true;
            if (this._errorCounter) {
                this._errorCounter.increment();
            }
            if (!(error instanceof Error)) {
                const errorText = (error && error.message) ||
                    (typeof error.toString === 'function' ? error.toString() : '');
                error = new Error(errorText);
            }
            this._safeCatchMode = false;
        }
        catch (internalError) {
            if (allowThrow) {
                throw internalError;
            }
            if (internalError && console && typeof console.error === 'function') {
                try {
                    console.error(internalError);
                }
                catch (_a) {
                }
            }
            this._safeCatchMode = false;
        }
    }
}

export { Co11yImpl, LazyMapToList, MetricsUtility, PublicSafety, UpCounterImpl, ValidationEntry, co11y, logValidator, maxItemCountAppLimit, maxStringLengthAppLimit, metricsUtility, payloadUtility, schemaUtil, utility };
//# sourceMappingURL=shared.js.map
