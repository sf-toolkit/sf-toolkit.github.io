"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerSa11yAutomaticChecks = exports.automaticCheck = exports.skipTest = exports.getOriginalDocumentBodyHtml = exports.setOriginalDocumentBodyHtml = void 0;
const common_1 = require("@sa11y/common");
const assert_1 = require("@sa11y/assert");
const format_1 = require("@sa11y/format");
const matcher_1 = require("./matcher");
const globals_1 = require("@jest/globals");
const preset_rules_1 = require("@sa11y/preset-rules");
/**
 * Default options when {@link registerSa11yAutomaticChecks} is invoked
 */
const defaultAutoCheckOpts = {
    runAfterEach: true,
    cleanupAfterEach: true,
    consolidateResults: true,
    filesFilter: [],
    runDOMMutationObserver: false,
    enableIncompleteResults: false,
};
let originalDocumentBodyHtml = null;
let mutatedNodes = [];
const setOriginalDocumentBodyHtml = (bodyHtml) => {
    originalDocumentBodyHtml = bodyHtml ?? null;
};
exports.setOriginalDocumentBodyHtml = setOriginalDocumentBodyHtml;
const getOriginalDocumentBodyHtml = () => {
    return originalDocumentBodyHtml;
};
exports.getOriginalDocumentBodyHtml = getOriginalDocumentBodyHtml;
/**
 * Check if current test file needs to be skipped based on any provided filter
 */
function skipTest(testPath, filesFilter) {
    if (!testPath || !filesFilter || !(filesFilter?.length > 0))
        return false;
    const skipTest = filesFilter.some((fileName) => testPath.toLowerCase().includes(fileName.toLowerCase()));
    if (skipTest) {
        (0, common_1.log)(`Skipping automatic accessibility check on ${testPath} as it matches given files filter: ${filesFilter.toString()}`);
    }
    return skipTest;
}
exports.skipTest = skipTest;
/**
 * Run accessibility check on each element node in the body using {@link toBeAccessible}
 * @param opts - Options for automatic checks {@link AutoCheckOpts}
 */
async function automaticCheck(opts = defaultAutoCheckOpts) {
    if (skipTest(globals_1.expect.getState().testPath, opts.filesFilter))
        return;
    // Skip automatic check if test is using fake timer as it would result in timeout
    if ((0, matcher_1.isTestUsingFakeTimer)()) {
        (0, common_1.log)('Skipping automatic accessibility check as Jest fake timer is in use.');
        return;
    }
    const customRules = (0, common_1.useCustomRules)();
    let config = customRules.length === 0
        ? (0, preset_rules_1.adaptA11yConfig)(preset_rules_1.defaultRuleset)
        : (0, preset_rules_1.adaptA11yConfigCustomRules)(preset_rules_1.defaultRuleset, customRules);
    if (opts.enableIncompleteResults)
        config = (0, preset_rules_1.adaptA11yConfigIncompleteResults)(config);
    let a11yResults = [];
    const currentDocumentHtml = document.body.innerHTML;
    if (originalDocumentBodyHtml) {
        document.body.innerHTML = originalDocumentBodyHtml;
    }
    // Create a DOM walker filtering only elements (skipping text, comment nodes etc)
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);
    let currNode = walker.firstChild();
    try {
        if (!opts.runDOMMutationObserver) {
            while (currNode !== null) {
                // TODO (spike): Use a logger lib with log levels selectable at runtime
                // console.log(
                //     `â™¿ [DEBUG] Automatically checking a11y of ${currNode.nodeName}
                //      for test "${expect.getState().currentTestName}"
                //      : ${testPath}`
                // );
                // W-10004832 - Exclude descendancy based rules from automatic checks
                a11yResults.push(...(await (0, assert_1.getA11yResultsJSDOM)(currNode, config, opts.enableIncompleteResults)));
                currNode = walker.nextSibling();
            }
        }
        else {
            a11yResults.push(...(await (0, assert_1.getA11yResultsJSDOM)(document.body, config, opts.enableIncompleteResults)));
            document.body.innerHTML = '';
            // loop mutated nodes
            for await (const mutatedNode of mutatedNodes) {
                if (mutatedNode) {
                    document.body.innerHTML = mutatedNode;
                    a11yResults.push(...(await (0, assert_1.getA11yResultsJSDOM)(document.body, config, opts.enableIncompleteResults)));
                }
            }
        }
    }
    finally {
        if (opts.runDOMMutationObserver) {
            mutatedNodes = [];
        }
        (0, exports.setOriginalDocumentBodyHtml)(null);
        document.body.innerHTML = currentDocumentHtml;
        if (opts.cleanupAfterEach)
            document.body.innerHTML = ''; // remove non-element nodes
        // TODO (spike): Disable stack trace for automatic checks.
        //  Will this affect all errors globally?
        // Error.stackTraceLimit = 0;
        if (process.env.SELECTOR_FILTER_KEYWORDS) {
            a11yResults = (0, format_1.exceptionListFilterSelectorKeywords)(a11yResults, process.env.SELECTOR_FILTER_KEYWORDS.split(','));
        }
        format_1.A11yError.checkAndThrow(a11yResults, { deduplicate: opts.consolidateResults });
    }
}
exports.automaticCheck = automaticCheck;
function observerCallback(mutations, _observer) {
    for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) => {
            if (node?.parentElement?.innerHTML) {
                mutatedNodes.push(node.parentElement.innerHTML);
            }
            else if (node?.outerHTML) {
                mutatedNodes.push(node?.outerHTML);
            }
        });
    }
}
// https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit
const observerOptions = {
    subtree: true,
    childList: true,
    attributes: true,
    characterData: true, // monitor changes to the character data contained within nodes
};
/**
 * Register accessibility checks to be run automatically after each test
 * @param opts - Options for automatic checks {@link AutoCheckOpts}
 */
function registerSa11yAutomaticChecks(opts = defaultAutoCheckOpts) {
    if (opts.runAfterEach) {
        const observer = new MutationObserver(observerCallback);
        // TODO (fix): Make registration idempotent
        (0, common_1.log)('Registering sa11y checks to be run automatically after each test');
        beforeEach(() => {
            if (opts.runDOMMutationObserver) {
                observer.observe(document.body, observerOptions);
            }
        });
        afterEach(async () => {
            if (opts.runDOMMutationObserver) {
                observer.disconnect(); // stop mutation observer
            }
            await automaticCheck(opts);
        });
    }
}
exports.registerSa11yAutomaticChecks = registerSa11yAutomaticChecks;
//# sourceMappingURL=automatic.js.map