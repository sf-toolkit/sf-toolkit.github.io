var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/lwr/src/cli/commands/build.ts
__markAsModule(exports);
__export(exports, {
  createBuildCommand: () => createBuildCommand
});
var import_commander = __toModule(require("commander"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_path = __toModule(require("path"));
var import_utils = __toModule(require("../utils.cjs"));
var import_config = __toModule(require("@lwrjs/config"));
var import_tools = __toModule(require("@lwrjs/tools"));
var RUNTIME_CONFIG_SRC_DIR = "config";
function createBuildCommand() {
  return new import_commander.Command("build").description("Build an LWR application").addOption((0, import_utils.getTargetOption)()).addOption((0, import_utils.getModeOption)().choices(["prod", "prod-compat"])).option("-o, --output <directory>", `[string] output directory`).option("--clean", `[boolean] delete the output directory`, false).option("-r, --routes <routes...>", `routes`).option("-m, --modules <modules...>", `modules`).option("-l, --locales <locales...>", `locales`).option("--minify", "[boolean] minifies build output", false).action(async (options, cmd) => {
    import_diagnostics.logger.info({label: `build`, message: `Building lwr application`});
    const {
      rootDir,
      config,
      output,
      mode,
      clean,
      target,
      minify,
      routes,
      modules,
      locales,
      logLevel
    } = cmd.optsWithGlobals();
    process.env.LWR_LOG_LEVEL = logLevel;
    const outputDir = output ? output : (0, import_utils.getDefaultBuildDirectory)(rootDir, config, target);
    const aConfig = (0, import_config.loadConfig)({rootDir, lwrConfigFile: config});
    let ssrFunctionNodeVersion;
    if (target === "mrt") {
      ssrFunctionNodeVersion = getSuggestedNodeVersion();
    }
    if (clean) {
      import_diagnostics.logger.info({label: `build`, message: `Clearing output directory: ${outputDir}`});
      import_fs_extra.default.rmSync(outputDir, {recursive: true, force: true});
    } else {
      if (import_fs_extra.default.existsSync(`${outputDir}`)) {
        import_diagnostics.logger.warn({
          label: `build`,
          message: `Output directory already exists. Previously generated files will not be deleted. If you did not intend to do this, re-run with --clean true`
        });
      }
    }
    const generatedSitePath = target === "mrt" ? import_path.default.join(outputDir, "site") : outputDir;
    const {generateStaticSite} = await Promise.resolve().then(() => __toModule(require("@lwrjs/core")));
    const theLocales = locales ? locales.map((l) => {
      return {id: l};
    }) : aConfig.appConfig.i18n?.locales || [];
    const i18n = {
      ...aConfig.appConfig.i18n,
      locales: theLocales
    };
    try {
      const _additionalRoutePaths = routes || aConfig.appConfig.staticSiteGenerator._additionalRoutePaths || [];
      const _additionalModules = modules || aConfig.appConfig.staticSiteGenerator._additionalModules || [];
      if (target === "mrt") {
        _additionalModules.push("@lwc/engine-server");
      }
      const staticSiteGenerator = {
        outputDir: generatedSitePath,
        skipCleanOutputDir: true,
        _additionalRoutePaths,
        _additionalModules
      };
      await generateStaticSite({
        serverMode: mode,
        staticSiteGenerator,
        i18n
      });
      stageProxyConfig(rootDir, outputDir);
    } catch (error) {
      import_diagnostics.logger.error(error);
    }
    if (target === "mrt") {
      (0, import_tools.dedupeBundles)(generatedSitePath, i18n);
      const config2 = aConfig.appConfig;
      const rootDir2 = config2.rootDir;
      try {
        process.env.SSR_STATIC_BUNDLES = "true";
        import_diagnostics.logger.info({label: `build`, message: `Generating ssr.js`});
        const {buildServer} = await Promise.resolve().then(() => __toModule(require("@lwrjs/tools")));
        const castMinify = minify == "false" ? false : !!minify;
        await buildServer({rootDir: rootDir2, serverMode: mode, staticSiteGenerator: {outputDir: "site"}}, {outputDir, minify: castMinify});
      } catch (error) {
        import_diagnostics.logger.error(error);
      }
      const dirsInConfig = [];
      try {
        import_fs_extra.default.writeFileSync(import_path.default.join(outputDir, "loader.js"), "");
        const packageJson = JSON.parse(import_fs_extra.default.readFileSync(import_path.default.join(rootDir2, "package.json"), "utf-8"));
        import_fs_extra.default.writeFileSync(import_path.default.join(outputDir, "package.json"), JSON.stringify({
          name: packageJson.name ? packageJson.name : "lwr-app",
          version: packageJson.version ? packageJson.version : "1.0.0"
        }, null, 4));
        import_diagnostics.logger.info({label: `build`, message: `copying source files`});
        const contentDir = config2.contentDir;
        if (import_fs_extra.default.existsSync(contentDir)) {
          const relPath = contentDir.substring(rootDir2.length);
          dirsInConfig.push(import_path.default.join(".", relPath, "**"));
          const contentOutputDir = import_path.default.join(outputDir, relPath);
          import_fs_extra.default.copySync(contentDir, contentOutputDir);
        }
        const layoutDir = config2.layoutsDir;
        if (import_fs_extra.default.existsSync(layoutDir)) {
          const relPath = layoutDir.substring(rootDir2.length);
          dirsInConfig.push(import_path.default.join(".", relPath, "**"));
          const layoutOutputDir = import_path.default.join(outputDir, relPath);
          import_fs_extra.default.copySync(layoutDir, layoutOutputDir);
        }
        const globalDataDir = config2.globalDataDir;
        if (import_fs_extra.default.existsSync(globalDataDir)) {
          const relPath = globalDataDir.substring(rootDir2.length);
          dirsInConfig.push(import_path.default.join(".", relPath, "**"));
          const globalDataOutputDir = import_path.default.join(outputDir, relPath);
          import_fs_extra.default.copySync(globalDataDir, globalDataOutputDir);
        }
      } catch (e) {
        import_diagnostics.logger.error(e);
      }
      import_diagnostics.logger.info({label: `build`, message: `generating default.json`});
      try {
        const configFile = import_path.default.join(rootDir2, RUNTIME_CONFIG_SRC_DIR, "default.json");
        const outputConfigFile = import_path.default.join(outputDir, RUNTIME_CONFIG_SRC_DIR, "default.json");
        import_fs_extra.default.ensureDirSync(import_path.default.join(outputDir, RUNTIME_CONFIG_SRC_DIR));
        if (import_fs_extra.default.existsSync(configFile)) {
          import_diagnostics.logger.warn({
            label: `build`,
            message: `You have a config file already defined, using that rather than generating one.`
          });
          import_fs_extra.default.copyFileSync(configFile, outputConfigFile);
        } else {
          const defaultConfigContent = {
            ssrEnabled: true,
            ssrOnly: ["config/**", "package.json", "ssr.js", "site/.metadata/**"],
            ssrShared: [],
            ssrParameters: {
              ssrFunctionNodeVersion,
              proxyConfigs: []
            }
          };
          defaultConfigContent.ssrOnly.push(...dirsInConfig);
          if (process.env.SSR_ONLY_DIRS) {
            defaultConfigContent.ssrOnly.push(...process.env.SSR_ONLY_DIRS.split(",").map((value) => value.trim()));
          }
          defaultConfigContent.ssrShared = process.env.ASSETS_ON_LAMBDA ? ["site/**"] : ["site/1/bundle/**", "site/1/resource/**"];
          if (process.env.SSR_SHARED_DIRS) {
            defaultConfigContent.ssrShared.push(...process.env.SSR_SHARED_DIRS.split(",").map((value) => value.trim()));
          }
          import_fs_extra.default.writeFileSync(outputConfigFile, JSON.stringify(defaultConfigContent, null, 4));
        }
      } catch (e) {
        import_diagnostics.logger.error(e);
      }
      import_diagnostics.logger.info({label: `build`, message: `complete`});
    }
  });
}
function getSuggestedNodeVersion() {
  const nodeVersion = process.version;
  const majorVersion = parseInt(nodeVersion.slice(1).split(".")[0]);
  return `${majorVersion}.x`;
}
function stageProxyConfig(rootDir, outputDir) {
  try {
    const configFile = import_path.default.join(rootDir, RUNTIME_CONFIG_SRC_DIR, "_proxy");
    const outputConfigFile = import_path.default.join(outputDir, RUNTIME_CONFIG_SRC_DIR, "_proxy");
    if (import_fs_extra.default.existsSync(configFile)) {
      import_diagnostics.logger.info({label: `build`, message: `staging proxy configuration`});
      import_fs_extra.default.ensureDirSync(import_path.default.join(outputDir, RUNTIME_CONFIG_SRC_DIR));
      import_fs_extra.default.copyFileSync(configFile, outputConfigFile);
    }
  } catch (e) {
    import_diagnostics.logger.error(e);
  }
}
