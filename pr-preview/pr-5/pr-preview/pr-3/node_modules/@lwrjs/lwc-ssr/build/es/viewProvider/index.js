import BaseViewProvider from '@lwrjs/base-view-provider';
import { logger } from '@lwrjs/diagnostics';
import { ViewSpan, getTracer } from '@lwrjs/instrumentation';
import { HYDRATE_CLIENT_VALUE, HYDRATE_DIRECTIVE, getFeatureFlags, hashContent, isSpecifier, moduleSpecifierToKebabCase, slugify, } from '@lwrjs/shared-utils';
import { LWC_SSR_PREFIX } from '../identity.js';
import { runServerBootstrap } from '../utils/ssr-bootstrap.js';
import { createSsrErrorMessage } from '../utils/utils.js';
export default class LwcViewProvider extends BaseViewProvider {
    constructor(_pluginConfig, providerConfig) {
        super();
        this.name = 'ssr-view-provider';
        this.moduleBundler = providerConfig.moduleBundler;
        this.resourceRegistry = providerConfig.resourceRegistry;
        this.routes = [...providerConfig.config.routes, ...providerConfig.config.errorRoutes];
        this.runtimeEnvironment = providerConfig.runtimeEnvironment;
        this.config = providerConfig.config;
    }
    async initialize() {
        return;
    }
    async getView(viewId) {
        // This view provider creates content templates from LWC component specifiers
        const specifier = viewId.contentTemplate?.component;
        if (!specifier || !isSpecifier(specifier)) {
            return;
        }
        return {
            name: specifier,
            slug: slugify(specifier),
            ownHash: hashContent(specifier),
            originalSource: specifier,
            filePath: specifier,
            viewId,
            render: async (runtimeParams) => {
                // SSR the root component (without passing any public properties)
                const { moduleBundler, resourceRegistry, runtimeEnvironment } = this;
                const debug = runtimeParams.query?.debug !== undefined;
                const element = moduleSpecifierToKebabCase(specifier);
                return getTracer().trace({
                    name: ViewSpan.RenderPage,
                    attributes: { specifier },
                }, async () => {
                    // SSR the page-level content template component
                    const { results = {}, errors } = await runServerBootstrap({ specifier: `${LWC_SSR_PREFIX}${viewId.id}/${specifier}`, props: {} }, moduleBundler, resourceRegistry, this.routes, {
                        runtimeEnvironment: { ...runtimeEnvironment, debug },
                        runtimeParams: runtimeParams,
                        config: this.config,
                    });
                    // Handle errors: fallback to CSR or throw
                    if (errors) {
                        const errorString = Object.values(errors).join(', ');
                        if (!debug && !getFeatureFlags().SSR_WITH_CSR_FALLBACK) {
                            // 500 error for the page request
                            throw new Error(errorString);
                        }
                        // fallback to CSR
                        const message = createSsrErrorMessage(specifier, errorString);
                        logger.warn(message, errors[specifier]?.stack); // TODO specific metadata for errors
                        return {
                            renderedView: `<${element} ${HYDRATE_DIRECTIVE}="${HYDRATE_CLIENT_VALUE}"></${element}>`,
                            // send an error message to the client if debug mode is on
                            metadata: {
                                serverDebug: { message: debug ? message : undefined },
                                customElements: [],
                                assetReferences: [],
                            },
                        };
                    }
                    // Insert the SSRed HTML into the document
                    const { html, props, cache } = results[specifier];
                    return {
                        // add "lwc:external" to the contentTemplate component to mark it as already processed
                        renderedView: html.replace(`<${element}`, `<${element} lwc:external`),
                        metadata: { serverData: props, customElements: [], assetReferences: [] },
                        cache,
                    };
                });
            },
        };
    }
}
//# sourceMappingURL=index.js.map