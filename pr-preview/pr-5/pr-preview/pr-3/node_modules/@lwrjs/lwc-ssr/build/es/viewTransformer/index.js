import { logger } from '@lwrjs/diagnostics';
import { ViewSpan, getTracer } from '@lwrjs/instrumentation';
import { HYDRATE_CLIENT_VALUE, HYDRATE_DIRECTIVE, getFeatureFlags, isCsrIsland, isHydrateOnLoad, kebabCaseToModuleSpecifier, shortestTtl, } from '@lwrjs/shared-utils';
import { LWC_SSR_PREFIX, SSR_PROPS_ATTR, getPropsId } from '../identity.js';
import { runServerBootstrap } from '../utils/ssr-bootstrap.js';
import { createSsrErrorMessage } from '../utils/utils.js';
export { createFetchEndowment } from '../utils/utils.js';
/**
 * This is a view transformer run by the view registry during linking of a page document/route (configured in lwr.config.json[routes]).
 * If the "ssr" bootstrap flag is on for the route, it will server-side render (SSR) each eligible custom element found in the page HTML.
 *
 * Flow:
 *  1. There is a request to generate a view (ie: page document) via the UI middleware or static site generation
 *  2. During view generation, the view registry runs all the registered view transformers (including this one)
 *  3. This view transformer links the SSRed string for EVERY eligible custom element (ie: root component) found in the page document:
 *      a) It requests a module which SSRs a given custom element, generated by "lwc-ssr/moduleProvider"
 *      b) A bundle is created for the generated server bootstrap module (see "./ssr-bootstrap")
 *      c) The bundle code is run inside a worker (see "./ssr-bootstrap"), with context stored in "workerData"
 *      d) RootComponent.getServerData() is run to preload data and <links>, if available
 *      e) The generated server bootstrap module (running the worker) passes the SSRed code string, data and cache info back to the main thread
 *      f) The SSRed string is used to overwrite/link each custom element (eg: "<c-app></c-app>") in the document (see "stringBuilder.overwrite")
 *      g) A script containing all the serialized properties is added for hydration
 * 4. The view/page document now contains SSRed components and data, which will be sent to the client
 * 5. During bootstrap on the client, the "lwr/init" module will hydrate the custom elements on the page, as needed
 */
export default function lwcSsrViewTransformer(options, { config, moduleBundler, resourceRegistry }) {
    const routes = [...config.routes, ...config.errorRoutes];
    return {
        name: 'ssr-lwc-transformer',
        async link(stringBuilder, viewContext, metadata) {
            if (!viewContext.view.bootstrap?.ssr) {
                return {}; // no SSR
            }
            logger.debug({ label: 'lwcSsrViewTransformer', message: 'link' });
            logger.verbose({
                label: 'lwcSsrViewTransformer',
                message: 'link input',
                additionalInfo: stringBuilder,
            });
            if (!metadata.serverData) {
                metadata.serverData = {};
            }
            if (!metadata.serverDebug) {
                metadata.serverDebug = {};
            }
            const { customElements, serverData, serverDebug } = metadata;
            const { debug } = viewContext.runtimeEnvironment;
            // Gather all the SSRable custom elements (ie: root components) into 1 list
            const ssrModules = getComponentsToSSR(customElements, stringBuilder);
            const rootSpecifiers = Object.values(ssrModules).map((m) => m.specifier);
            if (!rootSpecifiers.length) {
                return {}; // no SSR because there are no root eligible components
            }
            // SSR and gather the properties and links for each eligible custom element
            const islands = rootSpecifiers.join(',');
            const specifier = `${LWC_SSR_PREFIX}${viewContext.view.id}/${islands}`;
            const allProps = {};
            Object.entries(ssrModules).forEach(([s, info]) => (allProps[s] = info.props));
            let pageTtl;
            await getTracer().trace({ name: ViewSpan.RenderIsland, attributes: { specifiers: islands } }, async () => {
                const { results, errors } = await runServerBootstrap({ specifier, props: allProps, serverData }, moduleBundler, resourceRegistry, routes, viewContext);
                for (const root in results) {
                    const { html, props, cache } = results[root];
                    const { tagName, startOffset, endOffset, hydrate } = ssrModules[root];
                    pageTtl = shortestTtl(cache?.ttl, pageTtl);
                    if (html) {
                        // Add the props id to the HTML for the custom element
                        // eg: <some-cmp> -> <some-cmp data-lwr-props-id="1234">
                        // Then overwrite the custom element with the SSRed component string
                        let propsAttr = '';
                        if (hydrate) {
                            // Only serialize props for custom elements that are to be hydrated
                            const propsId = getPropsId();
                            propsAttr = ` ${SSR_PROPS_ATTR}="${propsId}"`;
                            serverData[propsId] = props;
                        }
                        const [, remain] = html.split(`<${tagName}`);
                        stringBuilder.overwrite(startOffset, endOffset, [`<${tagName}`, propsAttr, remain].join(''));
                    }
                }
                results && addPreloadLinks(results, stringBuilder);
                errors && handleErrors(errors, customElements, islands, debug, serverDebug);
            });
            logger.verbose({
                label: 'lwcSsrViewTransformer',
                message: 'response',
                additionalInfo: stringBuilder,
            });
            return { cache: { ttl: pageTtl } };
        },
    };
}
function getComponentsToSSR(customElements, stringBuilder) {
    const cmpInfo = {};
    for (const { tagName, location, props: rawProps = {} } of customElements.values()) {
        const isCsr = isCsrIsland(rawProps);
        if (isCsr && location) {
            // Strip the CSR-only island directive from the HTML
            const { startOffset, endOffset } = location;
            stringBuilder.overwrite(startOffset, endOffset, `<${tagName}></${tagName}>`);
        }
        if (!isCsr && !rawProps?.['lwc:external'] && location) {
            // Only SSR the custom elements which are NOT CSR islands or lwc:external
            const { startOffset, endOffset } = location;
            const specifier = kebabCaseToModuleSpecifier(tagName);
            const hydrate = isHydrateOnLoad(rawProps);
            const props = { ...rawProps };
            delete props[HYDRATE_DIRECTIVE];
            cmpInfo[specifier] = { startOffset, endOffset, props, tagName, specifier, hydrate };
        }
    }
    return cmpInfo;
}
function addPreloadLinks(results, stringBuilder) {
    // Create HTML <link> strings for each item in the links array
    let htmlLinks = '';
    const allLinks = [];
    Object.values(results).forEach(({ markup: { links = [] } = {} }) => allLinks.push(...links));
    allLinks.forEach(({ href, rel, as, fetchpriority }) => {
        const relStr = rel ? ` rel="${rel}"` : '', asStr = as ? ` as="${as}"` : '', fetchStr = fetchpriority ? ` fetchpriority="${fetchpriority}"` : '';
        htmlLinks += `<link href="${href}"${relStr}${asStr}${fetchStr}>\n`;
    });
    if (htmlLinks) {
        // Add all the links to the <head> section of the base document
        const headIndex = stringBuilder.original.indexOf('</head>');
        if (headIndex >= 0) {
            stringBuilder.prependLeft(headIndex, htmlLinks);
        }
        else {
            logger.error('Adding links during server-side rendering failed. Could not find the </head> tag.');
        }
    }
}
function handleErrors(errors, customElements, specifiers, debug, serverDebug) {
    const allErrors = Object.values(errors).join(', ');
    if (!debug && !getFeatureFlags().SSR_WITH_CSR_FALLBACK) {
        // 500 error for the page request
        throw new Error(allErrors);
    }
    // Fallback to CSR in debug mode or if enabled
    Object.entries(errors).forEach(([specifier, err]) => {
        const ce = customElements.find(({ tagName }) => specifier === kebabCaseToModuleSpecifier(tagName));
        if (ce) {
            // Fallback to CSR by adding lwr:hydrate="client-only" to the custom element
            // This ENSURES the component's JavaScript gets sent to the client for CSRing
            ce.props === undefined
                ? (ce.props = {
                    [HYDRATE_DIRECTIVE]: HYDRATE_CLIENT_VALUE,
                })
                : // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore - TS thinks that props may still be undefined
                    (ce.props[HYDRATE_DIRECTIVE] = HYDRATE_CLIENT_VALUE);
        }
        // Log error with stack details
        const errMessage = createSsrErrorMessage(specifier, err);
        logger.warn(errMessage, err.stack); // TODO specific metadata for errors
    });
    // Inform the client of the failing modules without exposing any additional
    // details (such as callstack) for security reasons
    if (debug) {
        serverDebug.message = createSsrErrorMessage(specifiers, allErrors);
    }
}
//# sourceMappingURL=index.js.map