var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/utils/utils.ts
__markAsModule(exports);
__export(exports, {
  FETCH_ENDOWMENT: () => FETCH_ENDOWMENT,
  FetchController: () => FetchController,
  TRACER: () => TRACER,
  createFetchEndowment: () => createFetchEndowment,
  createSsrErrorMessage: () => createSsrErrorMessage,
  getWatchdogTime: () => getWatchdogTime,
  startWatchdogTimer: () => startWatchdogTimer,
  stopWatchdogTimer: () => stopWatchdogTimer
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var DEFAULT_SSR_TIMEOUT = 5e3;
function getWatchdogTime() {
  const override = process.env.SSR_TIMEOUT;
  return override ? Number.parseInt(override) : DEFAULT_SSR_TIMEOUT;
}
function startWatchdogTimer(callback, time) {
  return setTimeout(callback, time);
}
function stopWatchdogTimer(timerId) {
  clearTimeout(timerId);
}
var FetchController = class {
  constructor(fetchEndowment) {
    this.controlledFetch = (request, init) => {
      if (this.killSwitchActivated) {
        return this.handleAbortError(request, void 0);
      }
      const controller = new AbortController();
      const updatedInit = {...init, signal: controller.signal};
      this.controllers.add(controller);
      const fetchPromise = this.fetchEndowment(request, updatedInit).catch((error) => {
        if (this.killSwitchActivated) {
          return this.handleAbortError(request, error);
        } else {
          throw error;
        }
      }).finally(() => {
        this.controllers.delete(controller);
      });
      return fetchPromise;
    };
    this.activateKillSwitch = () => {
      this.killSwitchActivated = true;
      this.controllers.forEach((controller) => {
        controller.abort();
      });
      this.controllers.clear();
    };
    this.killSwitchActivated = false;
    this.controllers = new Set();
    this.fetchEndowment = fetchEndowment;
  }
  handleAbortError(request, error) {
    const message = `Orphaned ${String(request)} request was killed. Async processes are not supported during SSR. For more information, see: https://developer.salesforce.com/docs/platform/lwr/guide/lwr-configure-component-ssr.html.`;
    import_diagnostics.logger.warn({label: `Server-side Rendering`, message}, error);
    return Promise.resolve(new Response(message, {status: 500}));
  }
};
function createFetchEndowment(trace, host = "", requestCount = 1) {
  return (request, init) => {
    let finalRequest;
    let finalUrl;
    if (request instanceof Request) {
      const curUrl = request.url;
      if (curUrl.startsWith("/")) {
        finalUrl = host + curUrl;
        finalRequest = new Request(finalUrl, request);
      } else {
        finalUrl = curUrl;
        finalRequest = request;
      }
    } else {
      const curUrl = typeof request === "string" ? request : request.toString();
      finalRequest = finalUrl = curUrl.startsWith("/") ? host + curUrl : curUrl;
    }
    const finalInit = {
      ...init,
      headers: {
        ...init?.headers,
        [import_shared_utils.REQUEST_DEPTH_HEADER]: String(requestCount)
      }
    };
    return trace({name: import_instrumentation.ViewSpan.Fetch, attributes: {url: String(finalUrl)}}, () => fetch(finalRequest, finalInit));
  };
}
var FETCH_ENDOWMENT = `
if(!globalThis.isFetchWrapped) {
globalThis.isFetchWrapped = true;
globalThis.fetchClassic = fetch;
const coreHost = workerData.host; delete workerData.host;
const requestDepth = workerData.requestDepth; delete workerData.requestDepth;
globalThis.fetch = (url, init) => {
    const headers = {...init?.headers, '${import_shared_utils.REQUEST_DEPTH_HEADER}': String(requestDepth)};
    const urlStr = typeof url === 'string' ? url : url.toString();
    const finalUrl = urlStr.startsWith('/') ? (coreHost || '') + url : url;
    return globalThis.trace({ name: 'lwr.view.ssr.fetch', attributes: { url: finalUrl } },
        () => fetchClassic(finalUrl, {...init, headers})
    );
}
}`;
var TRACER = `globalThis.trace = (id, fn) => fn()`;
function createSsrErrorMessage(specifier, e) {
  return `Server-side rendering for "${specifier}" failed. Falling back to client-side rendering. Reason: ${(0, import_diagnostics.stringifyError)(e)}`;
}
