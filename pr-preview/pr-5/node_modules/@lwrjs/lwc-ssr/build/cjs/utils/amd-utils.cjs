var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/utils/amd-utils.ts
__markAsModule(exports);
__export(exports, {
  getBundle: () => getBundle,
  getCode: () => getCode
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_identity = __toModule(require("../identity.cjs"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_url = __toModule(require("url"));
var LWC_SPECIFIERS = {csr: "lwc", ssr: "@lwc/engine-server"};
async function readableToString(readable) {
  let result = "";
  for await (const chunk of readable) {
    result += chunk;
  }
  return result;
}
var loaderShimSource;
async function getLoaderShim(resourceRegistry, runtimeEnvironment) {
  if (loaderShimSource !== void 0) {
    return loaderShimSource;
  }
  const specifier = (0, import_shared_utils.getFeatureFlags)().LEGACY_LOADER ? "lwr-loader-shim-legacy.bundle.min.js" : "lwr-loader-shim.bundle.min.js";
  const resource = await resourceRegistry.getResource({specifier}, runtimeEnvironment);
  if (resource) {
    const {stream} = resource;
    if (stream) {
      loaderShimSource = await readableToString(stream());
      return loaderShimSource;
    }
  }
}
function getLwrConfig(bundleSpecifier, lwrVersion, serverData) {
  return Object.assign({}, {
    autoBoot: true,
    bootstrapModule: `${bundleSpecifier}/v/${lwrVersion}`,
    disableInitDefer: true,
    endpoints: {
      uris: {mapping: "/1/mapping/amd/1/l/en-US/mp/"}
    },
    rootComponents: [],
    serverData
  }, (0, import_shared_utils.getFeatureFlags)().LEGACY_LOADER ? {
    baseUrl: "ssr"
  } : {
    baseUrl: "/",
    imports: {
      "any/thing.js": ["any/thing"]
    }
  });
}
function aliasLwcEngine(ssrSpecifier, aliases) {
  const csrSpecifier = ssrSpecifier.replace(aliases.ssr, aliases.csr);
  const ssrLwcAlias = (0, import_shared_utils.createAmdAlias)(csrSpecifier, ssrSpecifier);
  const unversionedAlias = (0, import_shared_utils.createAmdAlias)(LWC_SPECIFIERS.csr, ssrSpecifier);
  return `${ssrLwcAlias}${unversionedAlias}`;
}
var GLOBALTHIS_LWR = `globalThis.LWR = globalThis.LWR || {};`;
async function getCode(runtimeEnvironment, serverData, lwrVersion, bundleSpecifier, includedModules, resourceRegistry) {
  const loaderShimSource2 = await getLoaderShim(resourceRegistry, runtimeEnvironment);
  const lwrConfigString = JSON.stringify(getLwrConfig(bundleSpecifier, lwrVersion, serverData));
  const lwcSpecifier = includedModules.find((m) => m.startsWith(`${LWC_SPECIFIERS.ssr}/v`));
  const info = (0, import_identity.parseBootstrapSpecifier)(bundleSpecifier);
  const rootCmpSpecifiers = info ? info.rootSpecifiers.join(",") : bundleSpecifier;
  return [
    GLOBALTHIS_LWR,
    `Object.assign(globalThis.LWR, ${lwrConfigString});`,
    `Object.assign(globalThis.LWR, { onError: (err) => globalThis.resolver({ errors: { '${rootCmpSpecifiers}': err.message}})});`,
    loaderShimSource2 ? loaderShimSource2 : "",
    lwcSpecifier ? aliasLwcEngine(lwcSpecifier, LWC_SPECIFIERS) : ""
  ];
}
async function getBundle(specifier, moduleBundler, routes, runtimeEnvironment, runtimeParams) {
  if ((0, import_shared_utils.getFeatureFlags)().SSR_STATIC_BUNDLES) {
    return buildBundle(specifier, moduleBundler, routes, runtimeEnvironment, runtimeParams);
  }
  return bundle(specifier, moduleBundler, {
    ...runtimeEnvironment,
    bundle: true
  }, runtimeParams, {
    appendExcludes: false,
    exclude: ["lwc"]
  }).then(async (bundle2) => {
    bundle2.code = await appendFileBasedExternals(bundle2.code, bundle2.bundleRecord.dynamicImports, bundle2.bundleRecord.imports, new Set(), new Set());
    return bundle2;
  });
}
async function appendFileBasedExternals(bundleCode, dynamicImports = [], imports = [], visitedBundles, visitedExternals) {
  for (const {specifier, external, externalSrc} of [...imports, ...dynamicImports]) {
    if (!visitedBundles.has(specifier) && (!external || !externalSrc || !visitedExternals.has(externalSrc))) {
      visitedBundles.add(specifier);
      if (external && externalSrc) {
        visitedExternals.add(externalSrc);
        if (externalSrc && externalSrc.startsWith(import_shared_utils.PROTOCOL_FILE)) {
          const path = (0, import_url.fileURLToPath)(externalSrc);
          const externalBundle = import_fs_extra.default.readFileSync(path, {encoding: "utf-8"}).toString();
          bundleCode = bundleCode.concat(`
${externalBundle}`);
        }
      }
    }
  }
  return bundleCode;
}
async function bundle(specifier, moduleBundler, runtimeEnvironment, runtimeParams, bundleConfigOverrides) {
  return await moduleBundler.getModuleBundle({specifier}, runtimeEnvironment, runtimeParams, bundleConfigOverrides);
}
async function bundleImports(bundleCode, dynamicImports = [], imports = [], visited, moduleBundler, runtimeEnvironment, runtimeParams) {
  for (const {specifier} of imports) {
    if (!visited.has(specifier)) {
      visited.add(specifier);
      const {code, bundleRecord, version} = await bundle(specifier, moduleBundler, runtimeEnvironment, runtimeParams);
      const bundledCode = getBundledCode(runtimeEnvironment, specifier, version, code);
      bundleCode = await bundleImports(bundledCode, bundleRecord.dynamicImports, bundleRecord.imports, visited, moduleBundler, runtimeEnvironment, runtimeParams) + bundleCode;
    }
  }
  for (const {specifier} of dynamicImports) {
    if (!visited.has(specifier)) {
      visited.add(specifier);
      const {code, version} = await bundle(specifier, moduleBundler, runtimeEnvironment, runtimeParams);
      bundleCode += getBundledCode(runtimeEnvironment, specifier, version, code);
    }
  }
  return bundleCode;
}
function getBundledCode(runtimeEnvironment, specifier, version, code) {
  let bundledCode;
  if (runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES) {
    const aliasCode = (0, import_shared_utils.createAmdAlias)((0, import_shared_utils.getSpecifier)({specifier, version}), specifier);
    bundledCode = [code, aliasCode].filter(Boolean).join("");
  } else {
    bundledCode = code;
  }
  return bundledCode;
}
async function getBundleWithImports(specifier, moduleBundler, runtimeEnvironment, runtimeParams) {
  const {code, bundleRecord} = await bundle(specifier, moduleBundler, runtimeEnvironment, runtimeParams);
  return await bundleImports(code, bundleRecord.dynamicImports, bundleRecord.imports, new Set(["lwc", specifier]), moduleBundler, runtimeEnvironment, runtimeParams);
}
async function buildBundle(ssrSpecifier, moduleBundler, routes, runtimeEnvironment, runtimeParams) {
  const {rootSpecifiers, route} = (0, import_identity.parseBootstrapSpecifier)(ssrSpecifier, routes);
  const ssrServices = (0, import_identity.getSsrServices)(route);
  const serviceBundles = await Promise.all(ssrServices.map((s) => getBundleWithImports(s, moduleBundler, runtimeEnvironment, runtimeParams)));
  const serviceCode = serviceBundles.reduce((all, sc) => all + sc, "");
  let rootCode = "";
  for (const rootSpecifier of rootSpecifiers) {
    rootCode += await getBundleWithImports(rootSpecifier, moduleBundler, runtimeEnvironment, runtimeParams);
    if (runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES) {
      const aliasSpecifier = (0, import_shared_utils.getSpecifier)({
        specifier: rootSpecifier,
        version: "version-not-provided"
      });
      const aliasCode = (0, import_shared_utils.createAmdAlias)(aliasSpecifier, rootSpecifier);
      rootCode = [aliasCode, rootCode].join("");
    }
  }
  const {code: lwcEngineCode, version: lwcVersion} = await bundle(LWC_SPECIFIERS.ssr, moduleBundler, runtimeEnvironment, runtimeParams);
  const {
    bundleRecord,
    code: ssrCode,
    version: lwrVersion
  } = await bundle(ssrSpecifier, moduleBundler, runtimeEnvironment, runtimeParams, {
    appendExcludes: true,
    exclude: [LWC_SPECIFIERS.ssr, ...rootSpecifiers, ...ssrServices]
  });
  const code = serviceCode + rootCode + lwcEngineCode + ssrCode;
  bundleRecord.includedModules.push(`${LWC_SPECIFIERS.ssr}/v/${(0, import_shared_utils.normalizeVersionToUri)(lwcVersion)}`);
  return {
    bundleRecord,
    code,
    specifier: ssrSpecifier,
    version: lwrVersion
  };
}
